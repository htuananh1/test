import logging
import random
import json
import asyncio
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
import threading
import time
from github import Github
import base64
import os
from dotenv import load_dotenv
from concurrent.futures import ThreadPoolExecutor

load_dotenv()

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

BOT_TOKEN = os.getenv('BOT_TOKEN')
GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')
GITHUB_REPO = os.getenv('GITHUB_REPO', 'htuananh1/Data-manager')
GITHUB_FILE_PATH = "bot_data.json"

FISH_TYPES = {
    "üç§ T√©p": {
        "value": 2,
        "chance": 18,
        "exp": 1,
        "multiplier_chance": 3,
        "multiplier_range": (2, 4)
    },
    "ü¶ê T√¥m": {
        "value": 5, 
        "chance": 15, 
        "exp": 1,
        "multiplier_chance": 5,
        "multiplier_range": (2, 5)
    },
    "üêü C√° nh·ªè": {
        "value": 10, 
        "chance": 12, 
        "exp": 2,
        "multiplier_chance": 8,
        "multiplier_range": (2, 6)
    },
    "üê† C√° v√†ng": {
        "value": 30, 
        "chance": 10, 
        "exp": 5,
        "multiplier_chance": 10,
        "multiplier_range": (2, 8)
    },
    "üê° C√° n√≥c": {
        "value": 50, 
        "chance": 8, 
        "exp": 8,
        "multiplier_chance": 12,
        "multiplier_range": (3, 10)
    },
    "ü¶Ä Cua": {
        "value": 60,
        "chance": 7,
        "exp": 10,
        "multiplier_chance": 13,
        "multiplier_range": (3, 11)
    },
    "ü¶ë M·ª±c": {
        "value": 80, 
        "chance": 6, 
        "exp": 12,
        "multiplier_chance": 15,
        "multiplier_range": (3, 12)
    },
    "ü¶à C√° m·∫≠p nh·ªè": {
        "value": 100,
        "chance": 5,
        "exp": 15,
        "multiplier_chance": 16,
        "multiplier_range": (4, 13)
    },
    "üêô B·∫°ch tu·ªôc": {
        "value": 200, 
        "chance": 4, 
        "exp": 25,
        "multiplier_chance": 20,
        "multiplier_range": (5, 16)
    },
    "ü¶à C√° m·∫≠p l·ªõn": {
        "value": 300,
        "chance": 3,
        "exp": 30,
        "multiplier_chance": 22,
        "multiplier_range": (5, 17)
    },
    "üê¢ R√πa bi·ªÉn": {
        "value": 400,
        "chance": 2.5,
        "exp": 35,
        "multiplier_chance": 23,
        "multiplier_range": (6, 18)
    },
    "ü¶û T√¥m h√πm": {
        "value": 500, 
        "chance": 2, 
        "exp": 40,
        "multiplier_chance": 24,
        "multiplier_range": (6, 18)
    },
    "üêä C√° s·∫•u": {
        "value": 600,
        "chance": 1.5,
        "exp": 45,
        "multiplier_chance": 25,
        "multiplier_range": (7, 19)
    },
    "üêã C√° voi": {
        "value": 800, 
        "chance": 1, 
        "exp": 50,
        "multiplier_chance": 26,
        "multiplier_range": (8, 19)
    },
    "ü¶≠ H·∫£i c·∫©u": {
        "value": 700,
        "chance": 0.8,
        "exp": 55,
        "multiplier_chance": 27,
        "multiplier_range": (8, 19)
    },
    "‚ö° C√° ƒëi·ªán": {
        "value": 1000,
        "chance": 0.6,
        "exp": 60,
        "multiplier_chance": 28,
        "multiplier_range": (9, 20)
    },
    "üåü C√° th·∫ßn": {
        "value": 1500,
        "chance": 0.4,
        "exp": 80,
        "multiplier_chance": 29,
        "multiplier_range": (10, 20)
    },
    "üêâ R·ªìng bi·ªÉn": {
        "value": 2000,
        "chance": 0.3,
        "exp": 100,
        "multiplier_chance": 30,
        "multiplier_range": (12, 20)
    },
    "üíé Kho b√°u": {
        "value": 3000, 
        "chance": 0.2, 
        "exp": 150,
        "multiplier_chance": 35,
        "multiplier_range": (15, 20)
    },
    "üëë Vua ƒë·∫°i d∆∞∆°ng": {
        "value": 5000,
        "chance": 0.1,
        "exp": 200,
        "multiplier_chance": 40,
        "multiplier_range": (15, 20)
    }
}

FISHING_RODS = {
    "basic": {
        "name": "üé£ C·∫ßn c√¢u c∆° b·∫£n",
        "price": 0,
        "bonus": 0,
        "speed": 3.0,
        "rare_bonus": 1.0,
        "description": "C·∫ßn c√¢u m·∫∑c ƒë·ªãnh"
    },
    "bronze": {
        "name": "ü•â C·∫ßn c√¢u ƒë·ªìng",
        "price": 500,
        "bonus": 10,
        "speed": 2.5,
        "rare_bonus": 1.2,
        "description": "+10% c∆° h·ªôi | Nhanh 0.5s | Hi·∫øm x1.2"
    },
    "silver": {
        "name": "ü•à C·∫ßn c√¢u b·∫°c",
        "price": 1500,
        "bonus": 25,
        "speed": 2.0,
        "rare_bonus": 1.5,
        "description": "+25% c∆° h·ªôi | Nhanh 1s | Hi·∫øm x1.5"
    },
    "gold": {
        "name": "ü•á C·∫ßn c√¢u v√†ng",
        "price": 5000,
        "bonus": 50,
        "speed": 1.5,
        "rare_bonus": 2.0,
        "description": "+50% c∆° h·ªôi | Nhanh 1.5s | Hi·∫øm x2"
    },
    "diamond": {
        "name": "üíé C·∫ßn c√¢u kim c∆∞∆°ng",
        "price": 15000,
        "bonus": 100,
        "speed": 1.0,
        "rare_bonus": 3.0,
        "description": "x2 c∆° h·ªôi | Si√™u nhanh | Hi·∫øm x3"
    },
    "legendary": {
        "name": "‚ö° C·∫ßn c√¢u huy·ªÅn tho·∫°i",
        "price": 50000,
        "bonus": 200,
        "speed": 0.5,
        "rare_bonus": 5.0,
        "description": "x3 c∆° h·ªôi | T·ª©c th√¨ | Hi·∫øm x5"
    }
}

BAITS = {
    "worm": {
        "name": "ü™± Giun",
        "price": 5,
        "bonus": 5,
        "description": "+5% c∆° h·ªôi c√¢u ƒë∆∞·ª£c c√°"
    },
    "shrimp": {
        "name": "ü¶ê T√¥m nh·ªè",
        "price": 15,
        "bonus": 15,
        "description": "+15% c∆° h·ªôi c√¢u ƒë∆∞·ª£c c√° t·ªët"
    },
    "special": {
        "name": "‚ú® M·ªìi ƒë·∫∑c bi·ªát",
        "price": 50,
        "bonus": 30,
        "description": "+30% c∆° h·ªôi c√¢u ƒë∆∞·ª£c c√° hi·∫øm"
    },
    "golden": {
        "name": "üåü M·ªìi v√†ng",
        "price": 100,
        "bonus": 50,
        "description": "+50% c∆° h·ªôi & x2 nh√¢n ti·ªÅn"
    }
}

class DataManager:
    def __init__(self):
        self.data = {}
        self.lock = threading.Lock()
        self.executor = ThreadPoolExecutor(max_workers=5)
        self.github = Github(GITHUB_TOKEN)
        self.repo = self.github.get_repo(GITHUB_REPO)
        self.load_from_github()
        self.start_auto_save()
        self.auto_fishing_tasks = {}
    
    def load_from_github(self):
        try:
            file_content = self.repo.get_contents(GITHUB_FILE_PATH)
            content_str = base64.b64decode(file_content.content).decode()
            lines = content_str.strip().split('\n')
            self.data = {}
            for line in lines:
                if line.strip():
                    try:
                        user_data = json.loads(line)
                        if 'user_id' in user_data:
                            self.data[user_data['user_id']] = user_data
                    except:
                        pass
            logging.info("Loaded data from GitHub successfully")
        except Exception as e:
            logging.info(f"No existing data file or error: {e}")
            self.data = {}
    
    def save_to_github(self):
        with self.lock:
            try:
                lines = []
                for user_id, user_data in self.data.items():
                    user_data['user_id'] = user_id
                    lines.append(json.dumps(user_data, ensure_ascii=False))
                
                content = '\n'.join(lines)
                
                try:
                    file = self.repo.get_contents(GITHUB_FILE_PATH)
                    self.repo.update_file(
                        GITHUB_FILE_PATH,
                        f"Update bot data - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                        content,
                        file.sha
                    )
                except:
                    self.repo.create_file(
                        GITHUB_FILE_PATH,
                        f"Create bot data - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                        content
                    )
                
                logging.info("Saved data to GitHub successfully")
                return True
            except Exception as e:
                logging.error(f"Error saving to GitHub: {e}")
                return False
    
    def auto_save(self):
        while True:
            time.sleep(60)
            self.executor.submit(self.save_to_github)
    
    def start_auto_save(self):
        save_thread = threading.Thread(target=self.auto_save, daemon=True)
        save_thread.start()
    
    def get_user(self, user_id):
        user_id = str(user_id)
        with self.lock:
            if user_id not in self.data:
                self.data[user_id] = {
                    "username": "",
                    "coins": 100,
                    "exp": 0,
                    "level": 1,
                    "fishing_count": 0,
                    "win_count": 0,
                    "lose_count": 0,
                    "treasures_found": 0,
                    "total_multiplier": 0,
                    "best_multiplier": 0,
                    "auto_fishing": False,
                    "auto_bait": "none",
                    "inventory": {
                        "rod": "basic",
                        "baits": {"worm": 10, "shrimp": 0, "special": 0, "golden": 0},
                        "fish": {}
                    },
                    "daily_claimed": None,
                    "created_at": datetime.now().isoformat()
                }
            return self.data[user_id].copy()
    
    def update_user(self, user_id, data):
        user_id = str(user_id)
        with self.lock:
            self.data[user_id] = data
    
    def add_coins(self, user_id, amount):
        user_id = str(user_id)
        with self.lock:
            user = self.get_user(user_id)
            user["coins"] += amount
            self.data[user_id] = user
            return user["coins"]
    
    def add_exp(self, user_id, amount):
        user_id = str(user_id)
        with self.lock:
            user = self.get_user(user_id)
            user["exp"] += amount
            new_level = (user["exp"] // 100) + 1
            leveled_up = new_level > user["level"]
            if leveled_up:
                user["level"] = new_level
            self.data[user_id] = user
            return leveled_up

data_manager = DataManager()

def format_number(num):
    return "{:,}".format(num)

def get_level_title(level):
    titles = {
        1: "üê£ Ng∆∞·ªùi m·ªõi",
        5: "üé£ Th·ª£ c√¢u",
        10: "üê† Ng∆∞ d√¢n",
        20: "ü¶à Th·ªßy th·ªß",
        30: "‚öì Thuy·ªÅn tr∆∞·ªüng",
        50: "üè¥‚Äç‚ò†Ô∏è H·∫£i t·∫∑c",
        75: "üßú‚Äç‚ôÇÔ∏è Vua bi·ªÉn c·∫£",
        100: "üî± Poseidon",
        150: "üåä Th·∫ßn ƒë·∫°i d∆∞∆°ng",
        200: "‚ö° Huy·ªÅn tho·∫°i"
    }
    
    for min_level in sorted(titles.keys(), reverse=True):
        if level >= min_level:
            return titles[min_level]
    return titles[1]

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_name = update.effective_user.first_name
    
    user = data_manager.get_user(user_id)
    user["username"] = user_name
    data_manager.update_user(user_id, user)
    
    welcome_text = f"""
üéÆ **Ch√†o m·ª´ng {user_name} ƒë·∫øn v·ªõi Fishing Game Bot!** üéÆ

üé£ **Th√¥ng tin c·ªßa b·∫°n:**
‚îú üí∞ Xu: {format_number(user['coins'])}
‚îú ‚≠ê Level: {user['level']} - {get_level_title(user['level'])}
‚îú üéØ Kinh nghi·ªám: {user['exp']}
‚îî üé£ C·∫ßn c√¢u: {FISHING_RODS[user['inventory']['rod']]['name']}

üìú **L·ªánh c∆° b·∫£n:**
/menu - üì± Menu ch√≠nh
/fish - üé£ C√¢u c√° (c√≥ Auto)
/inventory - üéí Kho ƒë·ªì
/shop - üõçÔ∏è C·ª≠a h√†ng
/stats - üìä Th·ªëng k√™
/leaderboard - üèÜ BXH

üí° C√° c√≥ c∆° h·ªôi nh√¢n ti·ªÅn x2-x20!
üî• D√πng /fish ƒë·ªÉ c√¢u Auto!
    """
    
    await update.message.reply_text(welcome_text, parse_mode='Markdown')

async def menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton("üé£ C√¢u C√°", callback_data='game_fishing'),
            InlineKeyboardButton("ü§ñ Auto C√¢u", callback_data='auto_fishing')
        ],
        [
            InlineKeyboardButton("üé≤ Ch·∫µn L·∫ª", callback_data='game_chanle'),
            InlineKeyboardButton("üó∫Ô∏è T√¨m Kho B√°u", callback_data='game_treasure')
        ],
        [
            InlineKeyboardButton("üéí Kho ƒê·ªì", callback_data='view_inventory'),
            InlineKeyboardButton("üõçÔ∏è C·ª≠a H√†ng", callback_data='open_shop')
        ],
        [
            InlineKeyboardButton("üìä Th·ªëng K√™", callback_data='view_stats'),
            InlineKeyboardButton("üèÜ BXH", callback_data='leaderboard')
        ],
        [
            InlineKeyboardButton("üéÅ Qu√† H√†ng Ng√†y", callback_data='daily_reward')
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    user_id = update.effective_user.id
    user = data_manager.get_user(user_id)
    
    menu_text = f"""
üéÆ **MENU CH√çNH** üéÆ

üë§ {user['username']} | Level {user['level']}
üí∞ {format_number(user['coins'])} xu | ‚≠ê {user['exp']} EXP
üé£ C·∫ßn: {FISHING_RODS[user['inventory']['rod']]['name']}

Ch·ªçn ho·∫°t ƒë·ªông:
    """
    
    await update.message.reply_text(menu_text, reply_markup=reply_markup, parse_mode='Markdown')

async def fish(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """L·ªánh /fish v·ªõi t√πy ch·ªçn auto"""
    keyboard = [
        [
            InlineKeyboardButton("üé£ C√¢u 1 l·∫ßn", callback_data='fish_single'),
            InlineKeyboardButton("ü§ñ Auto c√¢u", callback_data='auto_fishing')
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "üé£ **CH·ªåN CH·∫æ ƒê·ªò C√ÇU C√Å**\nCh·ªçn ch·∫ø ƒë·ªô b·∫°n mu·ªën:",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def auto_fishing_task(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id: int, bait_type: str, message_id: int, chat_id: int):
    """Task auto c√¢u c√°"""
    count = 0
    total_coins = 0
    total_exp = 0
    fish_caught = {}
    
    while user_id in data_manager.auto_fishing_tasks and data_manager.auto_fishing_tasks[user_id]:
        count += 1
        user = data_manager.get_user(user_id)
        
        # Ki·ªÉm tra xu
        if user["coins"] < 10:
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=f"‚õî **AUTO ƒê√É D·ª™NG**\nH·∫øt xu! ƒê√£ c√¢u {count-1} l·∫ßn\nüí∞ T·ªïng thu: {format_number(total_coins)} xu",
                parse_mode='Markdown'
            )
            data_manager.auto_fishing_tasks[user_id] = False
            break
        
        # Ki·ªÉm tra m·ªìi
        if bait_type != 'none':
            if bait_type not in user['inventory']['baits'] or user['inventory']['baits'][bait_type] <= 0:
                await context.bot.edit_message_text(
                    chat_id=chat_id,
                    message_id=message_id,
                    text=f"‚õî **AUTO ƒê√É D·ª™NG**\nH·∫øt m·ªìi! ƒê√£ c√¢u {count-1} l·∫ßn\nüí∞ T·ªïng thu: {format_number(total_coins)} xu",
                    parse_mode='Markdown'
                )
                data_manager.auto_fishing_tasks[user_id] = False
                break
        
        # C√¢u c√°
        user["coins"] -= 10
        bonus = 0
        golden_multiplier = 1
        
        if bait_type != 'none' and bait_type in BAITS:
            user['inventory']['baits'][bait_type] -= 1
            if bait_type == 'golden':
                bonus = 50
                golden_multiplier = 2
            else:
                bonus = BAITS[bait_type]['bonus']
        
        rod_info = FISHING_RODS[user['inventory']['rod']]
        rod_bonus = rod_info['bonus']
        total_bonus = bonus + rod_bonus
        rare_multiplier = rod_info['rare_bonus']
        
        # Random c√°
        rand = random.uniform(0, 100)
        cumulative = 0
        caught_fish = None
        reward = 0
        exp = 0
        
        for fish_name, fish_data in FISH_TYPES.items():
            if fish_data["chance"] < 1:  # C√° hi·∫øm
                chance = fish_data["chance"] * rare_multiplier
            else:
                chance = fish_data["chance"] * (1 + total_bonus/100)
            
            cumulative += chance
            if rand <= cumulative:
                caught_fish = fish_name
                base_reward = fish_data["value"]
                exp = fish_data["exp"]
                
                multiplier = 1
                if random.randint(1, 100) <= fish_data["multiplier_chance"]:
                    min_mult, max_mult = fish_data["multiplier_range"]
                    multiplier = random.randint(min_mult, max_mult)
                    if golden_multiplier > 1:
                        multiplier *= golden_multiplier
                
                reward = base_reward * multiplier
                break
        
        if caught_fish:
            if caught_fish not in user['inventory']['fish']:
                user['inventory']['fish'][caught_fish] = 0
            user['inventory']['fish'][caught_fish] += 1
            
            if caught_fish not in fish_caught:
                fish_caught[caught_fish] = 0
            fish_caught[caught_fish] += 1
            
            user["coins"] += reward
            user["exp"] += exp
            user["fishing_count"] += 1
            user["win_count"] += 1
            
            total_coins += reward - 10
            total_exp += exp
        else:
            user["fishing_count"] += 1
            total_coins -= 10
        
        data_manager.update_user(user_id, user)
        
        # C·∫≠p nh·∫≠t message
        status_text = f"""
ü§ñ **AUTO FISHING ƒêANG CH·∫†Y** ü§ñ

üìä **Th·ªëng k√™ Auto:**
‚îú üîÑ S·ªë l·∫ßn: {count}
‚îú üí∞ T·ªïng thu: {format_number(total_coins)} xu
‚îú ‚≠ê T·ªïng EXP: {total_exp}
‚îî üí∞ Xu hi·ªán t·∫°i: {format_number(user['coins'])}

üêü **C√° ƒë√£ c√¢u:**
"""
        for fish, qty in sorted(fish_caught.items(), key=lambda x: x[1], reverse=True)[:5]:
            status_text += f"  {fish}: {qty}\n"
        
        status_text += f"\nüé£ C·∫ßn: {rod_info['name']}"
        if bait_type != 'none':
            status_text += f"\nü™± M·ªìi: {BAITS[bait_type]['name']} (c√≤n {user['inventory']['baits'][bait_type]})"
        
        keyboard = [[InlineKeyboardButton("üõë D·ª™NG AUTO", callback_data='stop_auto')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        try:
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=status_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        except:
            pass
        
        # Ch·ªù theo t·ªëc ƒë·ªô c·∫ßn c√¢u
        await asyncio.sleep(rod_info['speed'])
    
    # K·∫øt th√∫c auto
    if user_id in data_manager.auto_fishing_tasks:
        del data_manager.auto_fishing_tasks[user_id]

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    data = query.data
    
    if data == 'fish_single' or data == 'game_fishing':
        user = data_manager.get_user(user_id)
        cost = 10
        if user["coins"] < cost:
            await query.edit_message_text(f"‚ùå B·∫°n kh√¥ng ƒë·ªß xu! C·∫ßn {cost} xu ƒë·ªÉ c√¢u c√°.")
            return
        
        keyboard = [
            [InlineKeyboardButton(f"ü™± Giun ({user['inventory']['baits']['worm']})", 
                                callback_data='fish_bait_worm')],
            [InlineKeyboardButton(f"ü¶ê T√¥m ({user['inventory']['baits']['shrimp']})", 
                                callback_data='fish_bait_shrimp')],
            [InlineKeyboardButton(f"‚ú® ƒê·∫∑c bi·ªát ({user['inventory']['baits']['special']})", 
                                callback_data='fish_bait_special')],
            [InlineKeyboardButton(f"üåü V√†ng ({user['inventory']['baits'].get('golden', 0)})", 
                                callback_data='fish_bait_golden')],
            [InlineKeyboardButton("üé£ Kh√¥ng d√πng m·ªìi", callback_data='fish_bait_none')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        rod_info = FISHING_RODS[user['inventory']['rod']]
        await query.edit_message_text(
            f"üé£ **CH·ªåN M·ªíI C√ÇU (1 L·∫¶N)**\nüí∞ Ph√≠: 10 xu\nC·∫ßn: {rod_info['name']}\nT·ªëc ƒë·ªô: {rod_info['speed']}s\n\nCh·ªçn m·ªìi:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    elif data == 'auto_fishing':
        user = data_manager.get_user(user_id)
        
        keyboard = [
            [InlineKeyboardButton(f"ü™± Giun ({user['inventory']['baits']['worm']})", 
                                callback_data='auto_bait_worm')],
            [InlineKeyboardButton(f"ü¶ê T√¥m ({user['inventory']['baits']['shrimp']})", 
                                callback_data='auto_bait_shrimp')],
            [InlineKeyboardButton(f"‚ú® ƒê·∫∑c bi·ªát ({user['inventory']['baits']['special']})", 
                                callback_data='auto_bait_special')],
            [InlineKeyboardButton(f"üåü V√†ng ({user['inventory']['baits'].get('golden', 0)})", 
                                callback_data='auto_bait_golden')],
            [InlineKeyboardButton("üé£ Kh√¥ng d√πng m·ªìi", callback_data='auto_bait_none')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            f"ü§ñ **CH·ªåN M·ªíI CHO AUTO**\n‚ö†Ô∏è Auto s·∫Ω c√¢u li√™n t·ª•c cho ƒë·∫øn khi h·∫øt xu/m·ªìi\n\nCh·ªçn m·ªìi:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    elif data.startswith('auto_bait_'):
        bait_type = data.replace('auto_bait_', '')
        
        # Ki·ªÉm tra n·∫øu ƒëang auto
        if user_id in data_manager.auto_fishing_tasks and data_manager.auto_fishing_tasks[user_id]:
            await query.edit_message_text("‚ö†Ô∏è B·∫°n ƒëang auto r·ªìi! D√πng n√∫t D·ª™NG ƒë·ªÉ t·∫Øt.")
            return
        
        # B·∫Øt ƒë·∫ßu auto
        data_manager.auto_fishing_tasks[user_id] = True
        
        await query.edit_message_text("ü§ñ **B·∫ÆT ƒê·∫¶U AUTO FISHING...**")
        
        # T·∫°o task auto
        asyncio.create_task(auto_fishing_task(
            update,
            context,
            user_id,
            bait_type,
            query.message.message_id,
            query.message.chat_id
        ))
    
    elif data == 'stop_auto':
        if user_id in data_manager.auto_fishing_tasks:
            data_manager.auto_fishing_tasks[user_id] = False
            await query.edit_message_text("üõë **AUTO ƒê√É D·ª™NG**")
    
    elif data.startswith('fish_bait_'):
        bait_type = data.replace('fish_bait_', '')
        user = data_manager.get_user(user_id)
        
        if user["coins"] < 10:
            await query.edit_message_text("‚ùå B·∫°n kh√¥ng ƒë·ªß xu ƒë·ªÉ c√¢u c√°!")
            return
        
        if bait_type != 'none':
            if bait_type not in user['inventory']['baits'] or user['inventory']['baits'][bait_type] <= 0:
                await query.edit_message_text(f"‚ùå B·∫°n kh√¥ng c√≥ m·ªìi n√†y!\nüí° V√†o /shop ƒë·ªÉ mua m·ªìi.")
                return
        
        user["coins"] -= 10
        bonus = 0
        golden_multiplier = 1
        
        if bait_type != 'none' and bait_type in BAITS:
            user['inventory']['baits'][bait_type] -= 1
            if bait_type == 'golden':
                bonus = 50
                golden_multiplier = 2
            else:
                bonus = BAITS[bait_type]['bonus']
        
        data_manager.update_user(user_id, user)
        
        rod_info = FISHING_RODS[user['inventory']['rod']]
        rod_bonus = rod_info['bonus']
        total_bonus = bonus + rod_bonus
        rare_multiplier = rod_info['rare_bonus']
        
        await query.edit_message_text(f"üé£ ƒêang th·∫£ c√¢u... (ch·ªù {rod_info['speed']}s)")
        await asyncio.sleep(rod_info['speed'])
        
        rand = random.uniform(0, 100)
        cumulative = 0
        caught_fish = None
        reward = 0
        exp = 0
        multiplier = 1
        
        for fish_name, fish_data in FISH_TYPES.items():
            if fish_data["chance"] < 1:
                chance = fish_data["chance"] * rare_multiplier
            else:
                chance = fish_data["chance"] * (1 + total_bonus/100)
            
            cumulative += chance
            if rand <= cumulative:
                caught_fish = fish_name
                base_reward = fish_data["value"]
                exp = fish_data["exp"]
                
                if random.randint(1, 100) <= fish_data["multiplier_chance"]:
                    min_mult, max_mult = fish_data["multiplier_range"]
                    multiplier = random.randint(min_mult, max_mult)
                    if golden_multiplier > 1:
                        multiplier *= golden_multiplier
                
                reward = base_reward * multiplier
                break
        
        if caught_fish:
            user = data_manager.get_user(user_id)
            
            if caught_fish not in user['inventory']['fish']:
                user['inventory']['fish'][caught_fish] = 0
            user['inventory']['fish'][caught_fish] += 1
            
            user["coins"] += reward
            user["exp"] += exp
            new_level = (user["exp"] // 100) + 1
            leveled_up = new_level > user["level"]
            if leveled_up:
                user["level"] = new_level
            
            user["fishing_count"] += 1
            user["win_count"] += 1
            
            if user.get('best_multiplier', 0) < multiplier:
                user['best_multiplier'] = multiplier
            user['total_multiplier'] = user.get('total_multiplier', 0) + multiplier
            
            data_manager.update_user(user_id, user)
            
            result_text = f"""
üéâ **B·∫ÆT ƒê∆Ø·ª¢C!**
{caught_fish}
üí∞ +{format_number(reward)} xu"""
            
            if multiplier > 1:
                result_text += f" (x{multiplier} üî•)"
            
            result_text += f"""
‚≠ê +{exp} EXP
üì¶ ƒê√£ l∆∞u v√†o kho

üí∞ S·ªë d∆∞: {format_number(user['coins'])} xu"""
            
            if leveled_up:
                result_text += f"\n\nüéä **LEVEL UP! B·∫°n ƒë√£ ƒë·∫°t level {user['level']}!**"
        else:
            user = data_manager.get_user(user_id)
            user["fishing_count"] += 1
            data_manager.update_user(user_id, user)
            result_text = f"üò¢ Kh√¥ng c√¢u ƒë∆∞·ª£c g√¨!\nüí∞ S·ªë d∆∞: {format_number(user['coins'])} xu"
        
        await query.edit_message_text(result_text, parse_mode='Markdown')
    
    elif data == 'game_chanle':
        keyboard = [
            [
                InlineKeyboardButton("Ch·∫µn (10 xu)", callback_data='chanle_chan_10'),
                InlineKeyboardButton("L·∫ª (10 xu)", callback_data='chanle_le_10')
            ],
            [
                InlineKeyboardButton("Ch·∫µn (50 xu)", callback_data='chanle_chan_50'),
                InlineKeyboardButton("L·∫ª (50 xu)", callback_data='chanle_le_50')
            ],
            [
                InlineKeyboardButton("Ch·∫µn (100 xu)", callback_data='chanle_chan_100'),
                InlineKeyboardButton("L·∫ª (100 xu)", callback_data='chanle_le_100')
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            "üé≤ **TR√í CH∆†I CH·∫¥N L·∫∫** üé≤\nCh·ªçn ch·∫µn ho·∫∑c l·∫ª:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    elif data.startswith('chanle_'):
        parts = data.split('_')
        choice = parts[1]
        bet = int(parts[2])
        
        user = data_manager.get_user(user_id)
        
        if user["coins"] < bet:
            await query.edit_message_text(f"‚ùå B·∫°n kh√¥ng ƒë·ªß {bet} xu ƒë·ªÉ c∆∞·ª£c!")
            return
        
        dice = random.randint(1, 6)
        is_even = dice % 2 == 0
        
        if (choice == 'chan' and is_even) or (choice == 'le' and not is_even):
            user["coins"] += bet
            user["exp"] += 5
            user["win_count"] += 1
            result = f"""üéâ **TH·∫ÆNG!**
üé≤ X√∫c x·∫Øc: {dice}
üí∞ +{bet} xu
‚≠ê +5 EXP
üí∞ S·ªë d∆∞: {format_number(user['coins'])} xu"""
        else:
            user["coins"] -= bet
            user["lose_count"] += 1
            result = f"""üò¢ **THUA!**
üé≤ X√∫c x·∫Øc: {dice}
üí∞ -{bet} xu
üí∞ S·ªë d∆∞: {format_number(user['coins'])} xu"""
        
        data_manager.update_user(user_id, user)
        await query.edit_message_text(result, parse_mode='Markdown')
    
    elif data == 'game_treasure':
        user = data_manager.get_user(user_id)
        cost = 20
        if user["coins"] < cost:
            await query.edit_message_text(f"‚ùå B·∫°n kh√¥ng ƒë·ªß xu! C·∫ßn {cost} xu ƒë·ªÉ t√¨m kho b√°u.")
            return
        
        keyboard = []
        for i in range(4):
            row = []
            for j in range(4):
                row.append(InlineKeyboardButton("üì¶", callback_data=f"treasure_{i}_{j}"))
            keyboard.append(row)
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        treasure_pos = random.randint(0, 15)
        gold_positions = random.sample([i for i in range(16) if i != treasure_pos], 3)
        
        context.user_data['treasure_pos'] = treasure_pos
        context.user_data['gold_positions'] = gold_positions
        
        user["coins"] -= cost
        data_manager.update_user(user_id, user)
        
        await query.edit_message_text(
            f"""üó∫Ô∏è **T√åM KHO B√ÅU** üó∫Ô∏è
Ph√≠ ch∆°i: {cost} xu (ƒë√£ tr·ª´)
Ch·ªçn 1 h·ªôp ƒë·ªÉ t√¨m kho b√°u!

üíé Kho b√°u = 200 xu
üí∞ V√†ng = 50 xu
üí© Tr·ªëng = 0 xu""",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    elif data.startswith('treasure_'):
        parts = data.split('_')
        row = int(parts[1])
        col = int(parts[2])
        position = row * 4 + col
        
        treasure_pos = context.user_data.get('treasure_pos', -1)
        gold_positions = context.user_data.get('gold_positions', [])
        
        user = data_manager.get_user(user_id)
        
        if position == treasure_pos:
            reward = 200
            user["coins"] += reward
            user["exp"] += 20
            user["treasures_found"] += 1
            user["win_count"] += 1
            result = f"""üíé **KHO B√ÅU!**
+{reward} xu
‚≠ê +20 EXP
üí∞ S·ªë d∆∞: {format_number(user['coins'])} xu"""
        elif position in gold_positions:
            reward = 50
            user["coins"] += reward
            user["exp"] += 10
            result = f"""üí∞ **V√ÄNG!**
+{reward} xu
‚≠ê +10 EXP
üí∞ S·ªë d∆∞: {format_number(user['coins'])} xu"""
        else:
            user["lose_count"] += 1
            result = f"""üí© **TR·ªêNG!**
Kh√¥ng c√≥ g√¨ ·ªü ƒë√¢y!
üí∞ S·ªë d∆∞: {format_number(user['coins'])} xu"""
        
        data_manager.update_user(user_id, user)
        await query.edit_message_text(result, parse_mode='Markdown')
    
    elif data == 'view_inventory':
        user = data_manager.get_user(user_id)
        inv = user['inventory']
        total_fish = sum(inv['fish'].values()) if inv['fish'] else 0
        
        fish_list = ""
        if inv['fish']:
            for fish_name, count in sorted(inv['fish'].items(), key=lambda x: x[1], reverse=True)[:8]:
                fish_list += f"  {fish_name}: {count}\n"
        else:
            fish_list = "  Ch∆∞a c√≥ c√° n√†o\n"
        
        text = f"""
üéí **KHO ƒê·ªí**

üé£ C·∫ßn: {FISHING_RODS[inv['rod']]['name']}
ü™± M·ªìi: Giun x{inv['baits']['worm']} | T√¥m x{inv['baits']['shrimp']} | ƒêB x{inv['baits']['special']} | V√†ng x{inv['baits'].get('golden', 0)}

üêü C√° ({total_fish} con):
{fish_list}

üìà Nh√¢n cao nh·∫•t: x{user.get('best_multiplier', 0)}
        """
        
        keyboard = [
            [InlineKeyboardButton("üí∞ B√°n t·∫•t c·∫£ c√°", callback_data='sell_fish')],
            [InlineKeyboardButton("‚óÄÔ∏è Quay l·∫°i", callback_data='back_menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
    
    elif data == 'view_stats':
        user = data_manager.get_user(user_id)
        win_rate = (user['win_count'] / (user['win_count'] + user['lose_count']) * 100) if (user['win_count'] + user['lose_count']) > 0 else 0
        
        text = f"""
üìä **TH·ªêNG K√ä**

üë§ {user['username']}
üèÜ Level {user['level']} - {get_level_title(user['level'])}
‚≠ê {user['exp']} EXP
üí∞ {format_number(user['coins'])} xu

üìà **Th√†nh t√≠ch:**
üé£ C√¢u c√°: {user['fishing_count']} l·∫ßn
‚úÖ Th·∫Øng: {user['win_count']} l·∫ßn
‚ùå Thua: {user['lose_count']} l·∫ßn
üìä T·ª∑ l·ªá th·∫Øng: {win_rate:.1f}%
üíé Kho b√°u: {user['treasures_found']} l·∫ßn
üî• T·ªïng nh√¢n: x{user.get('total_multiplier', 0)}
‚ö° Nh√¢n cao nh·∫•t: x{user.get('best_multiplier', 0)}
        """
        
        await query.edit_message_text(text, parse_mode='Markdown')
    
    elif data == 'open_shop':
        keyboard = [
            [InlineKeyboardButton("üé£ C·∫ßn c√¢u", callback_data='shop_rods')],
            [InlineKeyboardButton("ü™± M·ªìi c√¢u", callback_data='shop_baits')],
            [InlineKeyboardButton("‚óÄÔ∏è Quay l·∫°i", callback_data='back_menu')]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            "üõçÔ∏è **C·ª¨A H√ÄNG**\nCh·ªçn danh m·ª•c:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    elif data == 'leaderboard':
        sorted_users = sorted(data_manager.data.items(), 
                             key=lambda x: x[1]['coins'], 
                             reverse=True)[:10]
        
        text = "üèÜ **B·∫¢NG X·∫æP H·∫†NG TOP 10** üèÜ\n\n"
        
        medals = ["ü•á", "ü•à", "ü•â"]
        for i, (uid, user_data) in enumerate(sorted_users, 1):
            medal = medals[i-1] if i <= 3 else f"{i}."
            text += f"{medal} {user_data.get('username', 'User')} - {format_number(user_data['coins'])} xu (Lv.{user_data['level']})\n"
        
        await query.edit_message_text(text, parse_mode='Markdown')
    
    elif data == 'daily_reward':
        user = data_manager.get_user(user_id)
        last_claim = user.get('daily_claimed')
        if last_claim:
            last_date = datetime.fromisoformat(last_claim)
            if (datetime.now() - last_date).days < 1:
                hours_left = 24 - (datetime.now() - last_date).total_seconds() / 3600
                await query.edit_message_text(
                    f"‚è∞ B·∫°n ƒë√£ nh·∫≠n qu√† h√¥m nay!\nQuay l·∫°i sau {hours_left:.1f} gi·ªù"
                )
                return
        
        reward = random.randint(50, 200)
        bonus_baits = random.randint(5, 15)
        
        user["coins"] += reward
        user['inventory']['baits']['worm'] += bonus_baits
        user['daily_claimed'] = datetime.now().isoformat()
        data_manager.update_user(user_id, user)
        
        await query.edit_message_text(
            f"üéÅ **PH·∫¶N TH∆Ø·ªûNG H√ÄNG NG√ÄY!**\n"
            f"üí∞ +{reward} xu\n"
            f"ü™± +{bonus_baits} m·ªìi giun\n"
            f"üí∞ S·ªë d∆∞: {format_number(user['coins'])} xu",
            parse_mode='Markdown'
        )
    
    elif data == 'shop_rods':
        user = data_manager.get_user(user_id)
        current_rod = user['inventory']['rod']
        
        text = "üé£ **C·ª¨A H√ÄNG C·∫¶N C√ÇU**\n\n"
        keyboard = []
        
        for rod_id, rod_info in FISHING_RODS.items():
            if rod_id == current_rod:
                text += f"‚úÖ {rod_info['name']} (ƒêang d√πng)\n\n"
            else:
                text += f"{rod_info['name']}\n"
                text += f"üí∞ {format_number(rod_info['price'])} xu\n"
                text += f"üìù {rod_info['description']}\n\n"
                
                if rod_info['price'] <= user['coins'] and rod_id != current_rod:
                    keyboard.append([InlineKeyboardButton(
                        f"Mua {rod_info['name']} ({format_number(rod_info['price'])} xu)",
                        callback_data=f'buy_rod_{rod_id}'
                    )])
        
        keyboard.append([InlineKeyboardButton("‚óÄÔ∏è Quay l·∫°i", callback_data='open_shop')])
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
    
    elif data == 'shop_baits':
        user = data_manager.get_user(user_id)
        
        text = "ü™± **C·ª¨A H√ÄNG M·ªíI C√ÇU**\n\n"
        keyboard = []
        
        for bait_id, bait_info in BAITS.items():
            current_amount = user['inventory']['baits'].get(bait_id, 0)
            text += f"{bait_info['name']}\n"
            text += f"üí∞ {bait_info['price']} xu/c√°i\n"
            text += f"üìù {bait_info['description']}\n"
            text += f"üì¶ ƒêang c√≥: {current_amount}\n\n"
            
            row = []
            for amount in [10, 50, 100]:
                total_price = bait_info['price'] * amount
                if total_price <= user['coins']:
                    row.append(InlineKeyboardButton(
                        f"x{amount} ({format_number(total_price)} xu)",
                        callback_data=f'buy_bait_{bait_id}_{amount}'
                    ))
            if row:
                keyboard.append(row)
        
        keyboard.append([InlineKeyboardButton("‚óÄÔ∏è Quay l·∫°i", callback_data='open_shop')])
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
    
    elif data.startswith('buy_rod_'):
        rod_id = data.replace('buy_rod_', '')
        rod_info = FISHING_RODS[rod_id]
        
        user = data_manager.get_user(user_id)
        
        if user['coins'] < rod_info['price']:
            await query.edit_message_text("‚ùå B·∫°n kh√¥ng ƒë·ªß xu!")
            return
        
        user["coins"] -= rod_info['price']
        user['inventory']['rod'] = rod_id
        data_manager.update_user(user_id, user)
        
        await query.edit_message_text(
            f"‚úÖ **MUA TH√ÄNH C√îNG!**\n"
            f"B·∫°n ƒë√£ mua {rod_info['name']}\n"
            f"üí∞ S·ªë d∆∞: {format_number(user['coins'])} xu",
            parse_mode='Markdown'
        )
    
    elif data.startswith('buy_bait_'):
        parts = data.split('_')
        bait_type = parts[2]
        amount = int(parts[3])
        bait_info = BAITS[bait_type]
        total_price = bait_info['price'] * amount
        
        user = data_manager.get_user(user_id)
        
        if user['coins'] < total_price:
            await query.edit_message_text("‚ùå B·∫°n kh√¥ng ƒë·ªß xu!")
            return
        
        user["coins"] -= total_price
        if bait_type not in user['inventory']['baits']:
            user['inventory']['baits'][bait_type] = 0
        user['inventory']['baits'][bait_type] += amount
        data_manager.update_user(user_id, user)
        
        await query.edit_message_text(
            f"‚úÖ **MUA TH√ÄNH C√îNG!**\n"
            f"B·∫°n ƒë√£ mua {amount} {bait_info['name']}\n"
            f"üí∞ S·ªë d∆∞: {format_number(user['coins'])} xu",
            parse_mode='Markdown'
        )
    
    elif data == 'sell_fish':
        user = data_manager.get_user(user_id)
        total_value = 0
        total_count = 0
        
        if user['inventory']['fish']:
            for fish_name, count in user['inventory']['fish'].items():
                for fish_type, fish_data in FISH_TYPES.items():
                    if fish_type == fish_name:
                        total_value += fish_data['value'] * count * 0.7
                        total_count += count
                        break
            
            user['inventory']['fish'] = {}
            user["coins"] += int(total_value)
            data_manager.update_user(user_id, user)
            
            await query.edit_message_text(
                f"üí∞ **B√ÅN TH√ÄNH C√îNG!**\n"
                f"ƒê√£ b√°n {total_count} con c√°\n"
                f"Thu ƒë∆∞·ª£c: {format_number(int(total_value))} xu\n"
                f"üí∞ S·ªë d∆∞: {format_number(user['coins'])} xu",
                parse_mode='Markdown'
            )
        else:
            await query.edit_message_text("‚ùå B·∫°n kh√¥ng c√≥ c√° ƒë·ªÉ b√°n!")
    
    elif data == 'back_menu':
        user = data_manager.get_user(user_id)
        keyboard = [
            [
                InlineKeyboardButton("üé£ C√¢u C√°", callback_data='game_fishing'),
                InlineKeyboardButton("ü§ñ Auto C√¢u", callback_data='auto_fishing')
            ],
            [
                InlineKeyboardButton("üé≤ Ch·∫µn L·∫ª", callback_data='game_chanle'),
                InlineKeyboardButton("üó∫Ô∏è T√¨m Kho B√°u", callback_data='game_treasure')
            ],
            [
                InlineKeyboardButton("üéí Kho ƒê·ªì", callback_data='view_inventory'),
                InlineKeyboardButton("üõçÔ∏è C·ª≠a H√†ng", callback_data='open_shop')
            ],
            [
                InlineKeyboardButton("üìä Th·ªëng K√™", callback_data='view_stats'),
                InlineKeyboardButton("üèÜ BXH", callback_data='leaderboard')
            ],
            [
                InlineKeyboardButton("üéÅ Qu√† H√†ng Ng√†y", callback_data='daily_reward')
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        menu_text = f"""
üéÆ **MENU CH√çNH** üéÆ

üë§ {user['username']} | Level {user['level']}
üí∞ {format_number(user['coins'])} xu | ‚≠ê {user['exp']} EXP
üé£ C·∫ßn: {FISHING_RODS[user['inventory']['rod']]['name']}

Ch·ªçn ho·∫°t ƒë·ªông:
        """
        
        await query.edit_message_text(menu_text, reply_markup=reply_markup, parse_mode='Markdown')

async def inventory(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user = data_manager.get_user(user_id)
    inv = user['inventory']
    
    total_fish = sum(inv['fish'].values()) if inv['fish'] else 0
    
    fish_list = ""
    if inv['fish']:
        for fish_name, count in sorted(inv['fish'].items(), key=lambda x: x[1], reverse=True)[:10]:
            fish_list += f"  {fish_name}: {count}\n"
    else:
        fish_list = "  Ch∆∞a c√≥ c√° n√†o\n"
    
    inventory_text = f"""
üéí **KHO ƒê·ªí C·ª¶A B·∫†N** üéí

**üé£ C·∫ßn c√¢u:**
{FISHING_RODS[inv['rod']]['name']}
{FISHING_RODS[inv['rod']]['description']}

**ü™± M·ªìi c√¢u:**
‚îú ü™± Giun: {inv['baits']['worm']}
‚îú ü¶ê T√¥m: {inv['baits']['shrimp']}
‚îú ‚ú® ƒê·∫∑c bi·ªát: {inv['baits']['special']}
‚îî üåü V√†ng: {inv['baits'].get('golden', 0)}

**üêü C√° ƒë√£ c√¢u:** (T·ªïng: {total_fish})
{fish_list}

**üìà Th·ªëng k√™ nh√¢n ti·ªÅn:**
‚îú T·ªïng nh√¢n: x{user.get('total_multiplier', 0)}
‚îî Cao nh·∫•t: x{user.get('best_multiplier', 0)}
    """
    
    keyboard = [
        [InlineKeyboardButton("üõçÔ∏è C·ª≠a h√†ng", callback_data='open_shop')],
        [InlineKeyboardButton("üí∞ B√°n c√°", callback_data='sell_fish')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(inventory_text, reply_markup=reply_markup, parse_mode='Markdown')

async def shop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("üé£ C·∫ßn c√¢u", callback_data='shop_rods')],
        [InlineKeyboardButton("ü™± M·ªìi c√¢u", callback_data='shop_baits')],
        [InlineKeyboardButton("‚óÄÔ∏è Quay l·∫°i", callback_data='back_menu')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    shop_text = """
üõçÔ∏è **C·ª¨A H√ÄNG** üõçÔ∏è

Ch√†o m·ª´ng ƒë·∫øn c·ª≠a h√†ng!
Ch·ªçn danh m·ª•c b·∫°n mu·ªën xem:
    """
    
    await update.message.reply_text(shop_text, reply_markup=reply_markup, parse_mode='Markdown')

async def leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    sorted_users = sorted(data_manager.data.items(), 
                         key=lambda x: x[1]['coins'], 
                         reverse=True)[:10]
    
    text = "üèÜ **B·∫¢NG X·∫æP H·∫†NG TOP 10** üèÜ\n\n"
    
    medals = ["ü•á", "ü•à", "ü•â"]
    for i, (user_id, user_data) in enumerate(sorted_users, 1):
        medal = medals[i-1] if i <= 3 else f"{i}."
        text += f"{medal} {user_data.get('username', 'User')} - {format_number(user_data['coins'])} xu (Lv.{user_data['level']})\n"
    
    await update.message.reply_text(text, parse_mode='Markdown')

async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user = data_manager.get_user(user_id)
    
    win_rate = (user['win_count'] / (user['win_count'] + user['lose_count']) * 100) if (user['win_count'] + user['lose_count']) > 0 else 0
    
    text = f"""
üìä **TH·ªêNG K√ä C·ª¶A B·∫†N** üìä

üë§ {user['username']}
üèÜ Level {user['level']} - {get_level_title(user['level'])}
‚≠ê {user['exp']} EXP
üí∞ {format_number(user['coins'])} xu

üìà **Th√†nh t√≠ch:**
üé£ C√¢u c√°: {user['fishing_count']} l·∫ßn
‚úÖ Th·∫Øng: {user['win_count']} l·∫ßn
‚ùå Thua: {user['lose_count']} l·∫ßn
üìä T·ª∑ l·ªá th·∫Øng: {win_rate:.1f}%
üíé Kho b√°u: {user['treasures_found']} l·∫ßn
üî• T·ªïng nh√¢n: x{user.get('total_multiplier', 0)}
‚ö° Nh√¢n cao nh·∫•t: x{user.get('best_multiplier', 0)}
    """
    
    await update.message.reply_text(text, parse_mode='Markdown')

async def chanle(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton("Ch·∫µn (10 xu)", callback_data='chanle_chan_10'),
            InlineKeyboardButton("L·∫ª (10 xu)", callback_data='chanle_le_10')
        ],
        [
            InlineKeyboardButton("Ch·∫µn (50 xu)", callback_data='chanle_chan_50'),
            InlineKeyboardButton("L·∫ª (50 xu)", callback_data='chanle_le_50')
        ],
        [
            InlineKeyboardButton("Ch·∫µn (100 xu)", callback_data='chanle_chan_100'),
            InlineKeyboardButton("L·∫ª (100 xu)", callback_data='chanle_le_100')
        ],
        [
            InlineKeyboardButton("Ch·∫µn (500 xu)", callback_data='chanle_chan_500'),
            InlineKeyboardButton("L·∫ª (500 xu)", callback_data='chanle_le_500')
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "üé≤ **TR√í CH∆†I CH·∫¥N L·∫∫** üé≤\nCh·ªçn ch·∫µn ho·∫∑c l·∫ª:",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def treasure(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user = data_manager.get_user(user_id)
    
    cost = 20
    if user["coins"] < cost:
        await update.message.reply_text(f"‚ùå B·∫°n kh√¥ng ƒë·ªß xu! C·∫ßn {cost} xu ƒë·ªÉ t√¨m kho b√°u.")
        return
    
    keyboard = []
    for i in range(4):
        row = []
        for j in range(4):
            row.append(InlineKeyboardButton("üì¶", callback_data=f"treasure_{i}_{j}"))
        keyboard.append(row)
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    treasure_pos = random.randint(0, 15)
    gold_positions = random.sample([i for i in range(16) if i != treasure_pos], 3)
    
    context.user_data['treasure_pos'] = treasure_pos
    context.user_data['gold_positions'] = gold_positions
    
    await update.message.reply_text(
        f"""üó∫Ô∏è **T√åM KHO B√ÅU** üó∫Ô∏è
Ph√≠ ch∆°i: {cost} xu
Ch·ªçn 1 h·ªôp ƒë·ªÉ t√¨m kho b√°u!

üíé Kho b√°u = 200 xu
üí∞ V√†ng = 50 xu
üí© Tr·ªëng = 0 xu""",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    
    data_manager.add_coins(user_id, -cost)

def main():
    application = Application.builder().token(BOT_TOKEN).build()
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("menu", menu))
    application.add_handler(CommandHandler("fish", fish))
    application.add_handler(CommandHandler("chanle", chanle))
    application.add_handler(CommandHandler("treasure", treasure))
    application.add_handler(CommandHandler("inventory", inventory))
    application.add_handler(CommandHandler("shop", shop))
    application.add_handler(CommandHandler("stats", stats))
    application.add_handler(CommandHandler("leaderboard", leaderboard))
    
    application.add_handler(CallbackQueryHandler(button_callback))
    
    print("ü§ñ Bot ƒëang ch·∫°y...")
    print("üìä D·ªØ li·ªáu t·ª± ƒë·ªông l∆∞u GitHub m·ªói 60 gi√¢y")
    print("üë• H·ªó tr·ª£ nhi·ªÅu ng∆∞·ªùi ch∆°i c√πng l√∫c")
    print("üî• Auto fishing ƒë√£ s·∫µn s√†ng!")
    application.run_polling()

if __name__ == '__main__':
    main()
