import logging
import random
import json
import asyncio
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
import threading
import time
from github import Github
import base64
import os
from dotenv import load_dotenv
from concurrent.futures import ThreadPoolExecutor
import psutil
import gc

load_dotenv()

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

BOT_TOKEN = os.getenv('BOT_TOKEN')
GITHUB_TOKEN = os.getenv('GITHUB_TOKEN')
GITHUB_REPO = os.getenv('GITHUB_REPO', 'htuananh1/Data-manager')
GITHUB_FILE_PATH = "bot_data.json"
LOCAL_BACKUP_FILE = "local_backup.json"

# Hi·ªáu ·ª©ng ƒë·∫∑c bi·ªát cho c√°
FISH_EFFECTS = {
    "bronze": {
        "name": "ü•â ƒê·ªìng",
        "multiplier": 3,
        "chance": 5,
        "color": "bronze"
    },
    "silver": {
        "name": "ü•à B·∫°c",
        "multiplier": 7,
        "chance": 2,
        "color": "silver"
    },
    "gold": {
        "name": "ü•á V√†ng",
        "multiplier": 15,
        "chance": 0.8,
        "color": "gold"
    },
    "rainbow": {
        "name": "üåà C·∫ßu v·ªìng",
        "multiplier": 30,
        "chance": 0.3,
        "color": "rainbow"
    },
    "zombie": {
        "name": "üßü Zombie",
        "multiplier": 50,
        "chance": 0.1,
        "color": "zombie"
    },
    "legendary": {
        "name": "‚ö° Huy·ªÅn tho·∫°i",
        "multiplier": 100,
        "chance": 0.05,
        "color": "legendary"
    },
    "mythic": {
        "name": "üîÆ Th·∫ßn tho·∫°i",
        "multiplier": 200,
        "chance": 0.01,
        "color": "mythic"
    }
}

FISH_TYPES = {
    # Common (15-25%)
    "üç§ T√©p": {
        "value": 2,
        "chance": 25,
        "exp": 1,
        "effect_chance": 5,
        "rarity": "common"
    },
    "ü¶ê T√¥m": {
        "value": 5, 
        "chance": 22, 
        "exp": 1,
        "effect_chance": 6,
        "rarity": "common"
    },
    "üêü C√° nh·ªè": {
        "value": 10, 
        "chance": 20, 
        "exp": 2,
        "effect_chance": 7,
        "rarity": "common"
    },
    "üê† C√° v√†ng": {
        "value": 30, 
        "chance": 18, 
        "exp": 5,
        "effect_chance": 8,
        "rarity": "common"
    },
    "ü¶Ä Cua nh·ªè": {
        "value": 25,
        "chance": 16,
        "exp": 4,
        "effect_chance": 8,
        "rarity": "common"
    },
    
    # Uncommon (8-15%)
    "üê° C√° n√≥c": {
        "value": 50, 
        "chance": 12, 
        "exp": 8,
        "effect_chance": 10,
        "rarity": "uncommon"
    },
    "ü¶Ä Cua l·ªõn": {
        "value": 60,
        "chance": 10,
        "exp": 10,
        "effect_chance": 12,
        "rarity": "uncommon"
    },
    "ü¶ë M·ª±c": {
        "value": 80, 
        "chance": 8, 
        "exp": 12,
        "effect_chance": 14,
        "rarity": "uncommon"
    },
    "üêö S√≤ ƒëi·ªáp": {
        "value": 70,
        "chance": 9,
        "exp": 11,
        "effect_chance": 13,
        "rarity": "uncommon"
    },
    "ü¶ê T√¥m h√πm nh·ªè": {
        "value": 90,
        "chance": 7,
        "exp": 13,
        "effect_chance": 15,
        "rarity": "uncommon"
    },
    
    # Rare (2-6%)
    "ü¶à C√° m·∫≠p nh·ªè": {
        "value": 150,
        "chance": 5,
        "exp": 20,
        "effect_chance": 18,
        "rarity": "rare"
    },
    "üêô B·∫°ch tu·ªôc": {
        "value": 200, 
        "chance": 4, 
        "exp": 25,
        "effect_chance": 20,
        "rarity": "rare"
    },
    "ü¶à C√° m·∫≠p l·ªõn": {
        "value": 300,
        "chance": 3,
        "exp": 30,
        "effect_chance": 22,
        "rarity": "rare"
    },
    "üê¢ R√πa bi·ªÉn": {
        "value": 400,
        "chance": 2.5,
        "exp": 35,
        "effect_chance": 24,
        "rarity": "rare"
    },
    "ü¶û T√¥m h√πm": {
        "value": 500, 
        "chance": 2, 
        "exp": 40,
        "effect_chance": 26,
        "rarity": "rare"
    },
    
    # Epic (0.5-2%)
    "üêä C√° s·∫•u": {
        "value": 800,
        "chance": 1.5,
        "exp": 50,
        "effect_chance": 30,
        "rarity": "epic"
    },
    "üêã C√° voi": {
        "value": 1000, 
        "chance": 1, 
        "exp": 60,
        "effect_chance": 32,
        "rarity": "epic"
    },
    "ü¶≠ H·∫£i c·∫©u": {
        "value": 900,
        "chance": 0.8,
        "exp": 55,
        "effect_chance": 34,
        "rarity": "epic"
    },
    "‚ö° C√° ƒëi·ªán": {
        "value": 1200,
        "chance": 0.6,
        "exp": 70,
        "effect_chance": 36,
        "rarity": "epic"
    },
    "üåü C√° th·∫ßn": {
        "value": 1500,
        "chance": 0.5,
        "exp": 80,
        "effect_chance": 38,
        "rarity": "epic"
    },
    
    # Legendary (0.1-0.5%)
    "üêâ R·ªìng bi·ªÉn": {
        "value": 2500,
        "chance": 0.4,
        "exp": 100,
        "effect_chance": 40,
        "rarity": "legendary"
    },
    "üíé Kho b√°u": {
        "value": 3000, 
        "chance": 0.3, 
        "exp": 120,
        "effect_chance": 42,
        "rarity": "legendary"
    },
    "üëë Vua ƒë·∫°i d∆∞∆°ng": {
        "value": 5000,
        "chance": 0.2,
        "exp": 150,
        "effect_chance": 45,
        "rarity": "legendary"
    },
    "üî± Th·ªßy th·∫ßn": {
        "value": 6000,
        "chance": 0.15,
        "exp": 180,
        "effect_chance": 48,
        "rarity": "legendary"
    },
    "üåä H·∫£i v∆∞∆°ng": {
        "value": 7000,
        "chance": 0.1,
        "exp": 200,
        "effect_chance": 50,
        "rarity": "legendary"
    },
    
    # Mythic (0.01-0.1%)
    "ü¶Ñ K·ª≥ l√¢n bi·ªÉn": {
        "value": 10000,
        "chance": 0.08,
        "exp": 300,
        "effect_chance": 55,
        "rarity": "mythic"
    },
    "üê≤ Long v∆∞∆°ng": {
        "value": 15000,
        "chance": 0.05,
        "exp": 400,
        "effect_chance": 60,
        "rarity": "mythic"
    },
    "‚òÑÔ∏è Thi√™n th·∫°ch": {
        "value": 20000,
        "chance": 0.03,
        "exp": 500,
        "effect_chance": 65,
        "rarity": "mythic"
    },
    "üåå V≈© tr·ª•": {
        "value": 25000,
        "chance": 0.02,
        "exp": 600,
        "effect_chance": 70,
        "rarity": "mythic"
    },
    "‚ú® Th·∫ßn th√°nh": {
        "value": 30000,
        "chance": 0.01,
        "exp": 700,
        "effect_chance": 75,
        "rarity": "mythic"
    },
    
    # Secret (0.001-0.01%)
    "üé≠ B√≠ ·∫©n": {
        "value": 50000,
        "chance": 0.008,
        "exp": 1000,
        "effect_chance": 80,
        "rarity": "secret"
    },
    "üóø C·ªï ƒë·∫°i": {
        "value": 75000,
        "chance": 0.005,
        "exp": 1500,
        "effect_chance": 85,
        "rarity": "secret"
    },
    "üõ∏ Ngo√†i h√†nh tinh": {
        "value": 100000,
        "chance": 0.003,
        "exp": 2000,
        "effect_chance": 90,
        "rarity": "secret"
    },
    "üîÆ H∆∞ kh√¥ng": {
        "value": 150000,
        "chance": 0.002,
        "exp": 3000,
        "effect_chance": 95,
        "rarity": "secret"
    },
    "‚≠ê Vƒ©nh h·∫±ng": {
        "value": 500000,
        "chance": 0.001,
        "exp": 5000,
        "effect_chance": 99,
        "rarity": "secret"
    }
}

FISHING_RODS = {
    "1": {
        "id": "basic",
        "name": "üé£ C·∫ßn c√¢u c∆° b·∫£n",
        "price": 0,
        "speed": 3.0,
        "auto_speed": 4.0,
        "common_bonus": 1.0,
        "rare_bonus": 0.5,
        "epic_bonus": 0.1,
        "legendary_bonus": 0.01,
        "mythic_bonus": 0.001,
        "secret_bonus": 0.0001,
        "description": "C·∫ßn m·∫∑c ƒë·ªãnh - C√° hi·∫øm r·∫•t kh√≥"
    },
    "2": {
        "id": "bamboo",
        "name": "üéã C·∫ßn tre",
        "price": 100,
        "speed": 2.8,
        "auto_speed": 3.8,
        "common_bonus": 1.1,
        "rare_bonus": 0.6,
        "epic_bonus": 0.15,
        "legendary_bonus": 0.02,
        "mythic_bonus": 0.002,
        "secret_bonus": 0.0002,
        "description": "Nh·∫π h∆°n - TƒÉng nh·∫π t·ª∑ l·ªá"
    },
    "3": {
        "id": "wooden",
        "name": "ü™µ C·∫ßn g·ªó",
        "price": 500,
        "speed": 2.5,
        "auto_speed": 3.5,
        "common_bonus": 1.2,
        "rare_bonus": 0.8,
        "epic_bonus": 0.2,
        "legendary_bonus": 0.05,
        "mythic_bonus": 0.005,
        "secret_bonus": 0.0005,
        "description": "C·∫ßn g·ªó ch·∫Øc - C√° th∆∞·ªùng t·ªët"
    },
    "4": {
        "id": "bronze",
        "name": "ü•â C·∫ßn ƒë·ªìng",
        "price": 1500,
        "speed": 2.3,
        "auto_speed": 3.3,
        "common_bonus": 1.3,
        "rare_bonus": 1.0,
        "epic_bonus": 0.3,
        "legendary_bonus": 0.08,
        "mythic_bonus": 0.008,
        "secret_bonus": 0.0008,
        "description": "Kim lo·∫°i ƒë·∫ßu - C√¢n b·∫±ng"
    },
    "5": {
        "id": "iron",
        "name": "‚öôÔ∏è C·∫ßn s·∫Øt",
        "price": 5000,
        "speed": 2.0,
        "auto_speed": 3.0,
        "common_bonus": 1.4,
        "rare_bonus": 1.5,
        "epic_bonus": 0.5,
        "legendary_bonus": 0.15,
        "mythic_bonus": 0.015,
        "secret_bonus": 0.001,
        "description": "C·ª©ng c√°p - C√° uncommon t·ªët"
    },
    "6": {
        "id": "silver",
        "name": "ü•à C·∫ßn b·∫°c",
        "price": 15000,
        "speed": 1.8,
        "auto_speed": 2.8,
        "common_bonus": 1.5,
        "rare_bonus": 2.0,
        "epic_bonus": 0.8,
        "legendary_bonus": 0.25,
        "mythic_bonus": 0.025,
        "secret_bonus": 0.0015,
        "description": "Qu√Ω kim - C√° rare xu·∫•t hi·ªán"
    },
    "7": {
        "id": "gold",
        "name": "ü•á C·∫ßn v√†ng",
        "price": 50000,
        "speed": 1.5,
        "auto_speed": 2.5,
        "common_bonus": 1.6,
        "rare_bonus": 3.0,
        "epic_bonus": 1.5,
        "legendary_bonus": 0.5,
        "mythic_bonus": 0.05,
        "secret_bonus": 0.002,
        "description": "Cao c·∫•p - C√° rare th∆∞·ªùng xuy√™n"
    },
    "8": {
        "id": "platinum",
        "name": "üíç C·∫ßn b·∫°ch kim",
        "price": 150000,
        "speed": 1.3,
        "auto_speed": 2.3,
        "common_bonus": 1.7,
        "rare_bonus": 4.0,
        "epic_bonus": 2.5,
        "legendary_bonus": 1.0,
        "mythic_bonus": 0.1,
        "secret_bonus": 0.003,
        "description": "Si√™u qu√Ω - Epic c√≥ th·ªÉ c√¢u"
    },
    "9": {
        "id": "crystal",
        "name": "üíé C·∫ßn pha l√™",
        "price": 500000,
        "speed": 1.0,
        "auto_speed": 2.0,
        "common_bonus": 1.8,
        "rare_bonus": 5.0,
        "epic_bonus": 4.0,
        "legendary_bonus": 2.0,
        "mythic_bonus": 0.2,
        "secret_bonus": 0.005,
        "description": "Tinh th·ªÉ - Epic d·ªÖ d√†ng"
    },
    "10": {
        "id": "diamond",
        "name": "üí† C·∫ßn kim c∆∞∆°ng",
        "price": 1500000,
        "speed": 0.8,
        "auto_speed": 1.8,
        "common_bonus": 2.0,
        "rare_bonus": 6.0,
        "epic_bonus": 6.0,
        "legendary_bonus": 3.5,
        "mythic_bonus": 0.5,
        "secret_bonus": 0.008,
        "description": "C·ª©ng nh·∫•t - Legendary xu·∫•t hi·ªán"
    },
    "11": {
        "id": "obsidian",
        "name": "üóø C·∫ßn h·∫Øc di·ªáu th·∫°ch",
        "price": 5000000,
        "speed": 0.6,
        "auto_speed": 1.5,
        "common_bonus": 2.2,
        "rare_bonus": 8.0,
        "epic_bonus": 10.0,
        "legendary_bonus": 6.0,
        "mythic_bonus": 1.0,
        "secret_bonus": 0.01,
        "description": "C·ªï ƒë·∫°i - Legendary th∆∞·ªùng"
    },
    "12": {
        "id": "mythril",
        "name": "‚öîÔ∏è C·∫ßn mythril",
        "price": 15000000,
        "speed": 0.5,
        "auto_speed": 1.3,
        "common_bonus": 2.5,
        "rare_bonus": 10.0,
        "epic_bonus": 15.0,
        "legendary_bonus": 10.0,
        "mythic_bonus": 2.0,
        "secret_bonus": 0.02,
        "description": "Huy·ªÅn tho·∫°i - Mythic c√≥ th·ªÉ"
    },
    "13": {
        "id": "celestial",
        "name": "‚ú® C·∫ßn thi√™n th·∫ßn",
        "price": 50000000,
        "speed": 0.4,
        "auto_speed": 1.0,
        "common_bonus": 3.0,
        "rare_bonus": 15.0,
        "epic_bonus": 25.0,
        "legendary_bonus": 20.0,
        "mythic_bonus": 5.0,
        "secret_bonus": 0.05,
        "description": "Thi√™n gi·ªõi - Mythic d·ªÖ d√†ng"
    },
    "14": {
        "id": "cosmic",
        "name": "üåå C·∫ßn v≈© tr·ª•",
        "price": 150000000,
        "speed": 0.3,
        "auto_speed": 0.8,
        "common_bonus": 3.5,
        "rare_bonus": 20.0,
        "epic_bonus": 40.0,
        "legendary_bonus": 35.0,
        "mythic_bonus": 10.0,
        "secret_bonus": 0.1,
        "description": "V≈© tr·ª• - Secret xu·∫•t hi·ªán"
    },
    "15": {
        "id": "eternal",
        "name": "‚ôæÔ∏è C·∫ßn vƒ©nh h·∫±ng",
        "price": 500000000,
        "speed": 0.2,
        "auto_speed": 0.5,
        "common_bonus": 5.0,
        "rare_bonus": 30.0,
        "epic_bonus": 60.0,
        "legendary_bonus": 50.0,
        "mythic_bonus": 20.0,
        "secret_bonus": 0.5,
        "description": "B·∫•t t·ª≠ - Secret th∆∞·ªùng xuy√™n"
    },
    "16": {
        "id": "omnipotent",
        "name": "üîÆ C·∫ßn to√†n nƒÉng",
        "price": 1000000000,
        "speed": 0.1,
        "auto_speed": 0.3,
        "common_bonus": 10.0,
        "rare_bonus": 50.0,
        "epic_bonus": 100.0,
        "legendary_bonus": 100.0,
        "mythic_bonus": 50.0,
        "secret_bonus": 1.0,
        "description": "T·ªëi th∆∞·ª£ng - M·ªçi c√° ƒë·ªÅu d·ªÖ"
    }
}

class LocalStorage:
    """Local storage for backup"""
    @staticmethod
    def save_local(data):
        try:
            with open(LOCAL_BACKUP_FILE, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            logging.info("Saved to local backup")
        except Exception as e:
            logging.error(f"Error saving local backup: {e}")
    
    @staticmethod
    def load_local():
        try:
            with open(LOCAL_BACKUP_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except:
            return {}

class ResourceMonitor:
    @staticmethod
    def get_system_stats():
        cpu_percent = psutil.cpu_percent(interval=0.1)
        memory = psutil.virtual_memory()
        return {
            "cpu": cpu_percent,
            "ram": memory.percent,
            "ram_used": memory.used / (1024**3),
            "ram_total": memory.total / (1024**3)
        }
    
    @staticmethod
    def check_resources():
        stats = ResourceMonitor.get_system_stats()
        if stats["cpu"] > 80:
            gc.collect()
            return False
        if stats["ram"] > 85:
            gc.collect()
            return False
        return True

class DataManager:
    def __init__(self):
        self.github = Github(GITHUB_TOKEN)
        self.repo = self.github.get_repo(GITHUB_REPO)
        self.auto_fishing_tasks = {}
        self.save_queue = []
        self.lock = threading.Lock()
        self.executor = ThreadPoolExecutor(max_workers=2)
        self.start_auto_save()
    
    def load_user_from_github(self, user_id):
        """Load user data directly from GitHub"""
        try:
            file_content = self.repo.get_contents(GITHUB_FILE_PATH)
            content_str = base64.b64decode(file_content.content).decode()
            lines = content_str.strip().split('\n')
            
            for line in lines:
                if line.strip():
                    try:
                        user_data = json.loads(line)
                        if user_data.get('user_id') == str(user_id):
                            return user_data
                    except:
                        pass
        except Exception as e:
            logging.error(f"Error loading user from GitHub: {e}")
            # Try local backup
            local_data = LocalStorage.load_local()
            if str(user_id) in local_data:
                return local_data[str(user_id)]
        
        return self.create_new_user(str(user_id))
    
    def create_new_user(self, user_id):
        """Create new user data"""
        return {
            "user_id": str(user_id),
            "username": "",
            "coins": 100,
            "exp": 0,
            "level": 1,
            "fishing_count": 0,
            "win_count": 0,
            "lose_count": 0,
            "treasures_found": 0,
            "total_effects": {},
            "best_multiplier": 0,
            "owned_rods": ["1"],  # Start with basic rod
            "inventory": {
                "rod": "1",
                "fish": {}
            },
            "daily_claimed": None,
            "created_at": datetime.now().isoformat()
        }
    
    def save_user_to_github(self, user_data):
        """Save single user to GitHub"""
        with self.lock:
            self.save_queue.append(user_data)
    
    def batch_save_to_github(self):
        """Batch save all queued users"""
        if not self.save_queue or not ResourceMonitor.check_resources():
            return
        
        with self.lock:
            if not self.save_queue:
                return
            
            users_to_save = self.save_queue.copy()
            self.save_queue.clear()
        
        try:
            all_users = {}
            try:
                file_content = self.repo.get_contents(GITHUB_FILE_PATH)
                content_str = base64.b64decode(file_content.content).decode()
                lines = content_str.strip().split('\n')
                
                for line in lines:
                    if line.strip():
                        try:
                            user_data = json.loads(line)
                            if 'user_id' in user_data:
                                all_users[user_data['user_id']] = user_data
                        except:
                            pass
            except:
                pass
            
            for user_data in users_to_save:
                all_users[user_data['user_id']] = user_data
            
            # Save to local backup
            LocalStorage.save_local(all_users)
            
            lines = []
            for user_id, data in all_users.items():
                data['user_id'] = user_id
                lines.append(json.dumps(data, ensure_ascii=False))
            
            content = '\n'.join(lines)
            
            try:
                file = self.repo.get_contents(GITHUB_FILE_PATH)
                self.repo.update_file(
                    GITHUB_FILE_PATH,
                    f"Update bot data - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                    content,
                    file.sha
                )
            except:
                self.repo.create_file(
                    GITHUB_FILE_PATH,
                    f"Create bot data - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                    content
                )
            
            logging.info(f"Saved {len(users_to_save)} users to GitHub")
        except Exception as e:
            logging.error(f"Error batch saving to GitHub: {e}")
    
    def auto_save(self):
        """Auto save every 30 seconds"""
        while True:
            time.sleep(30)
            if self.save_queue:
                self.executor.submit(self.batch_save_to_github)
    
    def start_auto_save(self):
        save_thread = threading.Thread(target=self.auto_save, daemon=True)
        save_thread.start()
    
    def get_user(self, user_id):
        """Get user data from GitHub"""
        return self.load_user_from_github(user_id)
    
    def update_user(self, user_id, data):
        """Update user data"""
        data['user_id'] = str(user_id)
        self.save_user_to_github(data)

data_manager = DataManager()

def format_number(num):
    return "{:,}".format(num)

def get_level_title(level):
    titles = {
        1: "üê£ Ng∆∞·ªùi m·ªõi",
        5: "üé£ Th·ª£ c√¢u",
        10: "üê† Ng∆∞ d√¢n",
        20: "ü¶à Th·ªßy th·ªß",
        30: "‚öì Thuy·ªÅn tr∆∞·ªüng",
        50: "üè¥‚Äç‚ò†Ô∏è H·∫£i t·∫∑c",
        75: "üßú‚Äç‚ôÇÔ∏è Vua bi·ªÉn c·∫£",
        100: "üî± Poseidon",
        150: "üåä Th·∫ßn ƒë·∫°i d∆∞∆°ng",
        200: "‚ö° Huy·ªÅn tho·∫°i",
        300: "üåå V≈© tr·ª•",
        500: "‚ôæÔ∏è Vƒ©nh h·∫±ng"
    }
    
    for min_level in sorted(titles.keys(), reverse=True):
        if level >= min_level:
            return titles[min_level]
    return titles[1]

def calculate_fish_effects(fish_data):
    """Calculate special effects for fish"""
    effects = []
    total_multiplier = 1
    
    base_effect_chance = fish_data.get("effect_chance", 10)
    
    for effect_id, effect_data in FISH_EFFECTS.items():
        roll = random.uniform(0, 100)
        if roll <= effect_data["chance"] * (base_effect_chance / 100):
            effects.append(effect_data)
            total_multiplier *= effect_data["multiplier"]
    
    if len(effects) > 3:
        effects = sorted(effects, key=lambda x: x["multiplier"], reverse=True)[:3]
        total_multiplier = 1
        for effect in effects:
            total_multiplier *= effect["multiplier"]
    
    return effects, total_multiplier

def get_rarity_color(rarity):
    """Get color emoji for rarity"""
    colors = {
        "common": "‚ö™",
        "uncommon": "üü¢",
        "rare": "üîµ",
        "epic": "üü£",
        "legendary": "üü°",
        "mythic": "üî¥",
        "secret": "‚ö´"
    }
    return colors.get(rarity, "‚ö™")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    user_name = update.effective_user.first_name
    
    user = data_manager.get_user(user_id)
    user["username"] = user_name
    data_manager.update_user(user_id, user)
    
    stats = ResourceMonitor.get_system_stats()
    
    welcome_text = f"""
üéÆ **Ch√†o m·ª´ng {user_name} ƒë·∫øn v·ªõi Fishing Game Bot!** üéÆ

üé£ **Th√¥ng tin c·ªßa b·∫°n:**
‚îú üí∞ Xu: {format_number(user['coins'])}
‚îú ‚≠ê Level: {user['level']} - {get_level_title(user['level'])}
‚îú üéØ Kinh nghi·ªám: {user['exp']}
‚îî üé£ C·∫ßn c√¢u: {FISHING_RODS[user['inventory']['rod']]['name']}

üìú **L·ªánh c∆° b·∫£n:**
/menu - üì± Menu ch√≠nh
/fish - üé£ C√¢u c√° (c√≥ Auto)
/rods - üé£ C·ª≠a h√†ng c·∫ßn c√¢u
/stats - üìä Th·ªëng k√™

üí° **ƒê·ªô hi·∫øm c√°:**
‚ö™Common üü¢Uncommon üîµRare üü£Epic üü°Legendary üî¥Mythic ‚ö´Secret

‚ö†Ô∏è **L∆∞u √Ω:** C·∫ßn x·ªãn m·ªõi c√¢u ƒë∆∞·ª£c c√° hi·∫øm!

üíª H·ªá th·ªëng: CPU {stats['cpu']:.1f}% | RAM {stats['ram']:.1f}%
    """
    
    await update.message.reply_text(welcome_text, parse_mode='Markdown')

async def menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton("üé£ C√¢u C√°", callback_data='game_fishing'),
            InlineKeyboardButton("ü§ñ Auto C√¢u", callback_data='auto_fishing')
        ],
        [
            InlineKeyboardButton("üé£ C·∫ßn C√¢u", callback_data='shop_rods'),
            InlineKeyboardButton("üó∫Ô∏è T√¨m Kho B√°u", callback_data='game_treasure')
        ],
        [
            InlineKeyboardButton("üéí Kho ƒê·ªì", callback_data='view_inventory'),
            InlineKeyboardButton("üé≤ Ch·∫µn L·∫ª", callback_data='game_chanle')
        ],
        [
            InlineKeyboardButton("üìä Th·ªëng K√™", callback_data='view_stats'),
            InlineKeyboardButton("üèÜ BXH", callback_data='leaderboard')
        ],
        [
            InlineKeyboardButton("üéÅ Qu√† H√†ng Ng√†y", callback_data='daily_reward'),
            InlineKeyboardButton("üíª H·ªá Th·ªëng", callback_data='system_info')
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    user_id = update.effective_user.id
    user = data_manager.get_user(user_id)
    
    menu_text = f"""
üéÆ **MENU CH√çNH** üéÆ

üë§ {user['username']} | Level {user['level']}
üí∞ {format_number(user['coins'])} xu | ‚≠ê {user['exp']} EXP
üé£ C·∫ßn: {FISHING_RODS[user['inventory']['rod']]['name']}

Ch·ªçn ho·∫°t ƒë·ªông:
    """
    
    await update.message.reply_text(menu_text, reply_markup=reply_markup, parse_mode='Markdown')

async def rods(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show rods shop command"""
    user_id = update.effective_user.id
    user = data_manager.get_user(user_id)
    
    # Initialize owned_rods if not exists
    if 'owned_rods' not in user:
        user['owned_rods'] = ["1"]
        data_manager.update_user(user_id, user)
    
    keyboard = []
    row = []
    count = 0
    
    for rod_id, rod_data in FISHING_RODS.items():
        if rod_id not in user['owned_rods']:
            button_text = f"{rod_id}"
            if user['coins'] >= rod_data['price']:
                button_text = f"‚úÖ {rod_id}"
            else:
                button_text = f"‚ùå {rod_id}"
            
            row.append(InlineKeyboardButton(button_text, callback_data=f'buy_rod_{rod_id}'))
            count += 1
            
            if count % 4 == 0:
                keyboard.append(row)
                row = []
    
    if row:
        keyboard.append(row)
    
    keyboard.append([InlineKeyboardButton("‚óÄÔ∏è Quay l·∫°i", callback_data='back_menu')])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    text = f"""
üé£ **C·ª¨A H√ÄNG C·∫¶N C√ÇU** üé£

üí∞ Xu c·ªßa b·∫°n: {format_number(user['coins'])}
üé£ C·∫ßn hi·ªán t·∫°i: {FISHING_RODS[user['inventory']['rod']]['name']}

üìù **Ch·ªçn s·ªë ƒë·ªÉ xem chi ti·∫øt v√† mua:**
‚úÖ = ƒê·ªß xu | ‚ùå = Ch∆∞a ƒë·ªß xu

**C·∫ßn ƒë√£ s·ªü h·ªØu:** {', '.join(user['owned_rods'])}
    """
    
    await update.message.reply_text(text, reply_markup=reply_markup, parse_mode='Markdown')

async def fish(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Fish command with auto option"""
    keyboard = [
        [
            InlineKeyboardButton("üé£ C√¢u 1 l·∫ßn", callback_data='fish_single'),
            InlineKeyboardButton("ü§ñ Auto c√¢u", callback_data='auto_fishing')
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await update.message.reply_text(
        "üé£ **CH·ªåN CH·∫æ ƒê·ªò C√ÇU C√Å**\n‚ö†Ô∏è Auto c√¢u ch·∫≠m h∆°n v√† kh√≥ ra c√° hi·∫øm!",
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )

async def process_fishing(user_id, is_auto=False):
    """Process fishing logic"""
    user = data_manager.get_user(user_id)
    
    if user["coins"] < 10:
        return None, "‚ùå Kh√¥ng ƒë·ªß xu! C·∫ßn 10 xu ƒë·ªÉ c√¢u c√°."
    
    user["coins"] -= 10
    rod_data = FISHING_RODS[user['inventory']['rod']]
    
    rand = random.uniform(0, 100)
    cumulative = 0
    caught_fish = None
    reward = 0
    exp = 0
    
    for fish_name, fish_data in FISH_TYPES.items():
        rarity = fish_data['rarity']
        if rarity == 'common':
            chance = fish_data["chance"] * rod_data['common_bonus']
        elif rarity == 'uncommon':
            chance = fish_data["chance"] * rod_data['common_bonus']
        elif rarity == 'rare':
            chance = fish_data["chance"] * rod_data['rare_bonus']
        elif rarity == 'epic':
            chance = fish_data["chance"] * rod_data['epic_bonus']
        elif rarity == 'legendary':
            chance = fish_data["chance"] * rod_data['legendary_bonus']
        elif rarity == 'mythic':
            chance = fish_data["chance"] * rod_data['mythic_bonus']
        elif rarity == 'secret':
            chance = fish_data["chance"] * rod_data['secret_bonus']
        else:
            chance = fish_data["chance"]
        
        if is_auto and rarity in ['epic', 'legendary', 'mythic', 'secret']:
            chance *= 0.5
        
        cumulative += chance
        if rand <= cumulative:
            caught_fish = fish_name
            base_reward = fish_data["value"]
            exp = fish_data["exp"]
            
            effects, effect_multiplier = calculate_fish_effects(fish_data)
            
            reward = base_reward * effect_multiplier
            break
    
    if caught_fish:
        if caught_fish not in user['inventory']['fish']:
            user['inventory']['fish'][caught_fish] = 0
        user['inventory']['fish'][caught_fish] += 1
        
        user["coins"] += reward
        user["exp"] += exp
        new_level = (user["exp"] // 100) + 1
        leveled_up = new_level > user["level"]
        if leveled_up:
            user["level"] = new_level
        
        user["fishing_count"] += 1
        user["win_count"] += 1
        
        if user.get('best_multiplier', 0) < effect_multiplier:
            user['best_multiplier'] = effect_multiplier
        
        if 'total_effects' not in user:
            user['total_effects'] = {}
        for effect in effects:
            effect_name = effect["name"]
            if effect_name not in user['total_effects']:
                user['total_effects'][effect_name] = 0
            user['total_effects'][effect_name] += 1
        
        data_manager.update_user(user_id, user)
        
        fish_rarity = ""
        for fname, fdata in FISH_TYPES.items():
            if fname == caught_fish:
                fish_rarity = fdata['rarity']
                break
        
        result = {
            "success": True,
            "fish": caught_fish,
            "rarity": fish_rarity,
            "reward": reward,
            "exp": exp,
            "effects": effects,
            "effect_multiplier": effect_multiplier,
            "leveled_up": leveled_up,
            "new_level": user["level"],
            "coins": user["coins"]
        }
        
        return result, None
    else:
        user["fishing_count"] += 1
        data_manager.update_user(user_id, user)
        return {"success": False, "coins": user["coins"]}, None

async def auto_fishing_task(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id: int, message_id: int, chat_id: int):
    """Auto fishing task"""
    count = 0
    total_coins = 0
    total_exp = 0
    fish_caught = {}
    effects_count = {}
    rarity_count = {
        "common": 0,
        "uncommon": 0,
        "rare": 0,
        "epic": 0,
        "legendary": 0,
        "mythic": 0,
        "secret": 0
    }
    
    while user_id in data_manager.auto_fishing_tasks and data_manager.auto_fishing_tasks[user_id]:
        if count % 10 == 0 and not ResourceMonitor.check_resources():
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=f"‚õî **AUTO T·∫†M D·ª™NG**\nH·ªá th·ªëng ƒëang qu√° t·∫£i!\nƒê√£ c√¢u {count} l·∫ßn",
                parse_mode='Markdown'
            )
            await asyncio.sleep(5)
            continue
        
        count += 1
        
        result, error = await process_fishing(user_id, is_auto=True)
        
        if error:
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=f"‚õî **AUTO ƒê√É D·ª™NG**\n{error}\nƒê√£ c√¢u {count-1} l·∫ßn\nüí∞ T·ªïng thu: {format_number(total_coins)} xu",
                parse_mode='Markdown'
            )
            data_manager.auto_fishing_tasks[user_id] = False
            break
        
        if result["success"]:
            fish_name = result["fish"]
            if fish_name not in fish_caught:
                fish_caught[fish_name] = 0
            fish_caught[fish_name] += 1
            
            rarity_count[result["rarity"]] += 1
            
            total_coins += result["reward"] - 10
            total_exp += result["exp"]
            
            for effect in result["effects"]:
                effect_name = effect["name"]
                if effect_name not in effects_count:
                    effects_count[effect_name] = 0
                effects_count[effect_name] += 1
        else:
            total_coins -= 10
        
        user = data_manager.get_user(user_id)
        rod_data = FISHING_RODS[user['inventory']['rod']]
        
        status_text = f"""
ü§ñ **AUTO FISHING ƒêANG CH·∫†Y** ü§ñ

üìä **Th·ªëng k√™ Auto:**
‚îú üîÑ S·ªë l·∫ßn: {count}
‚îú üí∞ T·ªïng thu: {format_number(total_coins)} xu
‚îú ‚≠ê T·ªïng EXP: {total_exp}
‚îî üí∞ Xu hi·ªán t·∫°i: {format_number(result['coins'] if result else user['coins'])} xu

üìà **ƒê·ªô hi·∫øm ƒë√£ c√¢u:**
"""
        for rarity, cnt in rarity_count.items():
            if cnt > 0:
                status_text += f"  {get_rarity_color(rarity)} {rarity}: {cnt}\n"
        
        status_text += "\nüêü **Top 5 c√°:**\n"
        for fish, qty in sorted(fish_caught.items(), key=lambda x: x[1], reverse=True)[:5]:
            status_text += f"  {fish}: {qty}\n"
        
        if effects_count:
            status_text += "\n‚ú® **Hi·ªáu ·ª©ng:**\n"
            for effect, qty in sorted(effects_count.items(), key=lambda x: x[1], reverse=True):
                status_text += f"  {effect}: {qty}\n"
        
        status_text += f"\nüé£ C·∫ßn: {rod_data['name']}"
        
        keyboard = [[InlineKeyboardButton("üõë D·ª™NG AUTO", callback_data='stop_auto')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        try:
            await context.bot.edit_message_text(
                chat_id=chat_id,
                message_id=message_id,
                text=status_text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        except:
            pass
        
        await asyncio.sleep(rod_data['auto_speed'])
    
    if user_id in data_manager.auto_fishing_tasks:
        del data_manager.auto_fishing_tasks[user_id]

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    user_id = query.from_user.id
    data = query.data
    
    if data == 'shop_rods':
        user = data_manager.get_user(user_id)
        
        if 'owned_rods' not in user:
            user['owned_rods'] = ["1"]
            data_manager.update_user(user_id, user)
        
        keyboard = []
        row = []
        count = 0
        
        for rod_id, rod_data in FISHING_RODS.items():
            if rod_id not in user['owned_rods']:
                button_text = f"{rod_id}"
                if user['coins'] >= rod_data['price']:
                    button_text = f"‚úÖ {rod_id}"
                else:
                    button_text = f"‚ùå {rod_id}"
                
                row.append(InlineKeyboardButton(button_text, callback_data=f'buy_rod_{rod_id}'))
                count += 1
                
                if count % 4 == 0:
                    keyboard.append(row)
                    row = []
        
        if row:
            keyboard.append(row)
        
        keyboard.append([InlineKeyboardButton("üîÑ ƒê·ªïi c·∫ßn", callback_data='change_rod')])
        keyboard.append([InlineKeyboardButton("‚óÄÔ∏è Quay l·∫°i", callback_data='back_menu')])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        text = f"""
üé£ **C·ª¨A H√ÄNG C·∫¶N C√ÇU** üé£

üí∞ Xu: {format_number(user['coins'])}
üé£ ƒêang d√πng: {FISHING_RODS[user['inventory']['rod']]['name']}

üìù Ch·ªçn s·ªë ƒë·ªÉ xem chi ti·∫øt:
‚úÖ = ƒê·ªß xu | ‚ùå = Ch∆∞a ƒë·ªß xu

**ƒê√£ s·ªü h·ªØu:** {', '.join(user['owned_rods'])}
        """
        
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
    
    elif data == 'change_rod':
        user = data_manager.get_user(user_id)
        
        keyboard = []
        row = []
        count = 0
        
        for rod_id in user.get('owned_rods', ["1"]):
            if rod_id != user['inventory']['rod']:
                rod_data = FISHING_RODS[rod_id]
                row.append(InlineKeyboardButton(f"{rod_id}. {rod_data['name'][:8]}", callback_data=f'equip_rod_{rod_id}'))
                count += 1
                
                if count % 2 == 0:
                    keyboard.append(row)
                    row = []
        
        if row:
            keyboard.append(row)
        
        keyboard.append([InlineKeyboardButton("‚óÄÔ∏è Quay l·∫°i", callback_data='shop_rods')])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            "üîÑ **CH·ªåN C·∫¶N ƒê·ªÇ TRANG B·ªä:**",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    elif data.startswith('equip_rod_'):
        rod_id = data.replace('equip_rod_', '')
        user = data_manager.get_user(user_id)
        
        if rod_id in user.get('owned_rods', []):
            user['inventory']['rod'] = rod_id
            data_manager.update_user(user_id, user)
            
            await query.edit_message_text(
                f"‚úÖ ƒê√£ trang b·ªã: {FISHING_RODS[rod_id]['name']}",
                parse_mode='Markdown'
            )
        else:
            await query.edit_message_text("‚ùå B·∫°n ch∆∞a s·ªü h·ªØu c·∫ßn n√†y!")
    
    elif data.startswith('buy_rod_'):
        rod_id = data.replace('buy_rod_', '')
        user = data_manager.get_user(user_id)
        rod_data = FISHING_RODS[rod_id]
        
        text = f"""
üé£ **{rod_data['name']}**

üí∞ Gi√°: {format_number(rod_data['price'])} xu
‚ö° T·ªëc ƒë·ªô: {rod_data['speed']}s
üìù {rod_data['description']}

üí∞ Xu c·ªßa b·∫°n: {format_number(user['coins'])}
        """
        
        keyboard = []
        if user['coins'] >= rod_data['price']:
            keyboard.append([InlineKeyboardButton("üí∞ MUA", callback_data=f'confirm_buy_{rod_id}')])
        keyboard.append([InlineKeyboardButton("‚óÄÔ∏è Quay l·∫°i", callback_data='shop_rods')])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
    
    elif data.startswith('confirm_buy_'):
        rod_id = data.replace('confirm_buy_', '')
        user = data_manager.get_user(user_id)
        rod_data = FISHING_RODS[rod_id]
        
        if user['coins'] < rod_data['price']:
            await query.edit_message_text("‚ùå Kh√¥ng ƒë·ªß xu!")
            return
        
        if 'owned_rods' not in user:
            user['owned_rods'] = ["1"]
        
        if rod_id in user['owned_rods']:
            await query.edit_message_text("‚ùå B·∫°n ƒë√£ s·ªü h·ªØu c·∫ßn n√†y!")
            return
        
        user['coins'] -= rod_data['price']
        user['owned_rods'].append(rod_id)
        user['inventory']['rod'] = rod_id
        data_manager.update_user(user_id, user)
        
        await query.edit_message_text(
            f"‚úÖ **MUA TH√ÄNH C√îNG!**\n{rod_data['name']}\nüí∞ C√≤n l·∫°i: {format_number(user['coins'])} xu",
            parse_mode='Markdown'
        )
    
    elif data == 'system_info':
        stats = ResourceMonitor.get_system_stats()
        text = f"""
üíª **TH√îNG TIN H·ªÜ TH·ªêNG** üíª

üìä **T√†i nguy√™n:**
‚îú üñ•Ô∏è CPU: {stats['cpu']:.1f}%
‚îú üíæ RAM: {stats['ram']:.1f}%
‚îú üìà RAM ƒë√£ d√πng: {stats['ram_used']:.2f} GB
‚îî üìâ RAM t·ªïng: {stats['ram_total']:.2f} GB

üë• **Bot:**
‚îú ü§ñ Auto ƒëang ch·∫°y: {len(data_manager.auto_fishing_tasks)}
‚îî ‚úÖ Tr·∫°ng th√°i: {'T·ªët' if ResourceMonitor.check_resources() else '‚ö†Ô∏è Cao'}
        """
        await query.edit_message_text(text, parse_mode='Markdown')
    
    elif data == 'fish_single' or data == 'game_fishing':
        user = data_manager.get_user(user_id)
        rod_data = FISHING_RODS[user['inventory']['rod']]
        
        await query.edit_message_text(f"üé£ ƒêang th·∫£ c√¢u... (ch·ªù {rod_data['speed']}s)")
        await asyncio.sleep(rod_data['speed'])
        
        result, error = await process_fishing(user_id, is_auto=False)
        
        if error:
            await query.edit_message_text(error)
            return
        
        if result["success"]:
            result_text = f"""
üéâ **B·∫ÆT ƒê∆Ø·ª¢C!**
{result['fish']} {get_rarity_color(result['rarity'])}
üí∞ +{format_number(result['reward'])} xu"""
            
            if result['effects']:
                result_text += f"\n‚ú® Hi·ªáu ·ª©ng: "
                for effect in result['effects']:
                    result_text += f"{effect['name']} "
                result_text += f"\nüî• T·ªïng nh√¢n: x{result['effect_multiplier']}"
            
            result_text += f"""
‚≠ê +{result['exp']} EXP
üì¶ ƒê√£ l∆∞u v√†o kho

üí∞ S·ªë d∆∞: {format_number(result['coins'])} xu"""
            
            if result['leveled_up']:
                result_text += f"\n\nüéä **LEVEL UP! B·∫°n ƒë√£ ƒë·∫°t level {result['new_level']}!**"
        else:
            result_text = f"üò¢ Kh√¥ng c√¢u ƒë∆∞·ª£c g√¨!\nüí∞ S·ªë d∆∞: {format_number(result['coins'])} xu"
        
        await query.edit_message_text(result_text, parse_mode='Markdown')
    
    elif data == 'auto_fishing':
        if user_id in data_manager.auto_fishing_tasks and data_manager.auto_fishing_tasks[user_id]:
            await query.edit_message_text("‚ö†Ô∏è B·∫°n ƒëang auto r·ªìi! D√πng n√∫t D·ª™NG ƒë·ªÉ t·∫Øt.")
            return
        
        if not ResourceMonitor.check_resources():
            await query.edit_message_text("‚ö†Ô∏è H·ªá th·ªëng ƒëang qu√° t·∫£i! Th·ª≠ l·∫°i sau.")
            return
        
        data_manager.auto_fishing_tasks[user_id] = True
        
        await query.edit_message_text("ü§ñ **B·∫ÆT ƒê·∫¶U AUTO FISHING...**")
        
        asyncio.create_task(auto_fishing_task(
            update,
            context,
            user_id,
            query.message.message_id,
            query.message.chat_id
        ))
    
    elif data == 'stop_auto':
        if user_id in data_manager.auto_fishing_tasks:
            data_manager.auto_fishing_tasks[user_id] = False
            await query.edit_message_text("üõë **AUTO ƒê√É D·ª™NG**")
    
    elif data == 'game_chanle':
        keyboard = [
            [
                InlineKeyboardButton("Ch·∫µn (10 xu)", callback_data='chanle_chan_10'),
                InlineKeyboardButton("L·∫ª (10 xu)", callback_data='chanle_le_10')
            ],
            [
                InlineKeyboardButton("Ch·∫µn (50 xu)", callback_data='chanle_chan_50'),
                InlineKeyboardButton("L·∫ª (50 xu)", callback_data='chanle_le_50')
            ],
            [
                InlineKeyboardButton("Ch·∫µn (100 xu)", callback_data='chanle_chan_100'),
                InlineKeyboardButton("L·∫ª (100 xu)", callback_data='chanle_le_100')
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            "üé≤ **TR√í CH∆†I CH·∫¥N L·∫∫** üé≤\nCh·ªçn ch·∫µn ho·∫∑c l·∫ª:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    
    # ... (Continue with other callbacks like before)
    
    elif data == 'back_menu':
        user = data_manager.get_user(user_id)
        keyboard = [
            [
                InlineKeyboardButton("üé£ C√¢u C√°", callback_data='game_fishing'),
                InlineKeyboardButton("ü§ñ Auto C√¢u", callback_data='auto_fishing')
            ],
            [
                InlineKeyboardButton("üé£ C·∫ßn C√¢u", callback_data='shop_rods'),
                InlineKeyboardButton("üó∫Ô∏è T√¨m Kho B√°u", callback_data='game_treasure')
            ],
            [
                InlineKeyboardButton("üéí Kho ƒê·ªì", callback_data='view_inventory'),
                InlineKeyboardButton("üé≤ Ch·∫µn L·∫ª", callback_data='game_chanle')
            ],
            [
                InlineKeyboardButton("üìä Th·ªëng K√™", callback_data='view_stats'),
                InlineKeyboardButton("üèÜ BXH", callback_data='leaderboard')
            ],
            [
                InlineKeyboardButton("üéÅ Qu√† H√†ng Ng√†y", callback_data='daily_reward'),
                InlineKeyboardButton("üíª H·ªá Th·ªëng", callback_data='system_info')
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        menu_text = f"""
üéÆ **MENU CH√çNH** üéÆ

üë§ {user['username']} | Level {user['level']}
üí∞ {format_number(user['coins'])} xu | ‚≠ê {user['exp']} EXP
üé£ C·∫ßn: {FISHING_RODS[user['inventory']['rod']]['name']}

Ch·ªçn ho·∫°t ƒë·ªông:
        """
        
        await query.edit_message_text(menu_text, reply_markup=reply_markup, parse_mode='Markdown')

def main():
    application = Application.builder().token(BOT_TOKEN).build()
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("menu", menu))
    application.add_handler(CommandHandler("fish", fish))
    application.add_handler(CommandHandler("rods", rods))
    
    application.add_handler(CallbackQueryHandler(button_callback))
    
    print("ü§ñ Bot ƒëang ch·∫°y...")
    print("üìä Data t·ª´ GitHub + Local backup")
    print("üé£ 16 lo·∫°i c·∫ßn c√¢u v·ªõi h·ªá th·ªëng s·ªü h·ªØu")
    print("‚ú® Menu c√≥ C·∫ßn C√¢u, ·∫©n c·∫ßn ƒë√£ mua")
    
    stats = ResourceMonitor.get_system_stats()
    print(f"üíª CPU: {stats['cpu']:.1f}% | RAM: {stats['ram']:.1f}%")
    
    application.run_polling()

if __name__ == '__main__':
    main()
