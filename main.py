import os
import re
import asyncio
import io
import logging
import random
import datetime
import base64
import json
from typing import Optional, Dict, List, Tuple, Any, Union
from collections import deque, defaultdict
from dataclasses import dataclass, field
from enum import Enum
import time
import aiohttp
import requests

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.constants import ParseMode, ChatAction
from telegram.ext import (
    ApplicationBuilder, 
    ContextTypes, 
    MessageHandler, 
    filters, 
    CommandHandler, 
    CallbackQueryHandler
)
from telegram.error import BadRequest, TimedOut, NetworkError
from openai import OpenAI

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("linh_bot")

# Vietnam Constants
VIETNAM_CITIES = {
    "hanoi": {"name": "H√† N·ªôi", "lat": 21.0285, "lon": 105.8542},
    "hcm": {"name": "TP.HCM", "lat": 10.8231, "lon": 106.6297},
    "danang": {"name": "ƒê√† N·∫µng", "lat": 16.0544, "lon": 108.2022},
    "haiphong": {"name": "H·∫£i Ph√≤ng", "lat": 20.8449, "lon": 106.6881},
    "cantho": {"name": "C·∫ßn Th∆°", "lat": 10.0452, "lon": 105.7469},
    "nhatrang": {"name": "Nha Trang", "lat": 12.2388, "lon": 109.1967},
    "dalat": {"name": "ƒê√† L·∫°t", "lat": 11.9404, "lon": 108.4583},
    "hue": {"name": "Hu·∫ø", "lat": 16.4637, "lon": 107.5909},
    "vungtau": {"name": "V≈©ng T√†u", "lat": 10.3460, "lon": 107.0843},
    "quynhon": {"name": "Quy Nh∆°n", "lat": 13.7830, "lon": 109.2197}
}

VIETNAM_HOLIDAYS = {
    "01-01": "T·∫øt D∆∞∆°ng L·ªãch",
    "30-04": "Ng√†y Gi·∫£i ph√≥ng mi·ªÅn Nam", 
    "01-05": "Ng√†y Qu·ªëc t·∫ø Lao ƒë·ªông",
    "02-09": "Ng√†y Qu·ªëc kh√°nh"
}

@dataclass
class Config:
    BOT_TOKEN: str = field(default_factory=lambda: os.getenv("BOT_TOKEN", ""))
    
    # Vercel AI API
    VERCEL_API_KEY: str = field(default_factory=lambda: os.getenv("VERCEL_API_KEY", ""))
    BASE_URL: str = field(default_factory=lambda: os.getenv("BASE_URL", "https://ai-gateway.vercel.sh/v1"))
    
    # Text models
    CHAT_MODEL: str = field(default_factory=lambda: os.getenv("CHAT_MODEL", "anthropic/claude-3.5-haiku"))
    CODE_MODEL: str = field(default_factory=lambda: os.getenv("CODE_MODEL", "anthropic/claude-3.5-sonnet"))
    FILE_MODEL: str = field(default_factory=lambda: os.getenv("FILE_MODEL", "anthropic/claude-3.5-sonnet"))
    IMAGE_GEN_MODEL: str = field(default_factory=lambda: os.getenv("IMAGE_GEN_MODEL", "black-forest-labs/flux-schnell"))
    
    # Token limits
    MAX_TOKENS: int = field(default_factory=lambda: int(os.getenv("MAX_TOKENS", "1500")))
    MAX_TOKENS_CODE: int = field(default_factory=lambda: int(os.getenv("MAX_TOKENS_CODE", "4000")))
    FILE_OUTPUT_TOKENS: int = field(default_factory=lambda: int(os.getenv("FILE_OUTPUT_TOKENS", "6000")))
    
    # Processing limits
    CHUNK_CHARS: int = field(default_factory=lambda: int(os.getenv("CHUNK_CHARS", "120000")))
    CTX_TURNS: int = field(default_factory=lambda: int(os.getenv("CTX_TURNS", "15")))
    REQUEST_TIMEOUT: float = field(default_factory=lambda: float(os.getenv("REQUEST_TIMEOUT", "90")))
    
    # External APIs
    WEATHER_API_KEY: str = field(default_factory=lambda: os.getenv("WEATHER_API_KEY", ""))
    NEWS_API_KEY: str = field(default_factory=lambda: os.getenv("NEWS_API_KEY", ""))
    
    # Cache
    CACHE_TTL: int = 3600
    MAX_CACHE_SIZE: int = 100

config = Config()

# Import optional libraries
try:
    import chardet
except ImportError:
    chardet = None

try:
    import PyPDF2
except ImportError:
    PyPDF2 = None

try:
    import docx
    from docx import Document as DocxDocument
except ImportError:
    docx = None
    DocxDocument = None

try:
    import openpyxl
except ImportError:
    openpyxl = None

try:
    from pptx import Presentation
except ImportError:
    Presentation = None

try:
    from bs4 import BeautifulSoup
except ImportError:
    BeautifulSoup = None

class FileType(Enum):
    TEXT = "text"
    CODE = "code"
    PDF = "pdf"
    DOCX = "docx"
    XLSX = "xlsx"
    PPTX = "pptx"
    HTML = "html"
    JSON = "json"
    CSV = "csv"
    ARCHIVE = "archive"
    UNKNOWN = "unknown"

ARCHIVES = (".zip", ".rar", ".7z", ".tar", ".tar.gz", ".tgz", ".tar.bz2", ".tar.xz")
TEXT_LIKE = (
    ".txt", ".md", ".log", ".csv", ".tsv", ".json", ".yaml", ".yml", 
    ".ini", ".cfg", ".env", ".xml", ".html", ".htm", ".toml"
)
CODE_EXTENSIONS = (
    ".py", ".js", ".ts", ".java", ".c", ".cpp", ".cs", ".go", 
    ".php", ".rb", ".rs", ".sh", ".bat", ".ps1", ".sql", ".swift",
    ".kt", ".scala", ".r", ".m", ".dart", ".lua", ".pl", ".asm",
    ".jsx", ".tsx", ".vue", ".sol"
)

@dataclass
class UserState:
    history: deque = field(default_factory=lambda: deque(maxlen=32))
    file_mode: bool = False
    pending_file: Optional[Dict[str, Any]] = None
    last_result: str = ""
    language: str = "vi"
    location: str = "hanoi"

class BotState:
    def __init__(self):
        self.users: Dict[int, UserState] = defaultdict(UserState)
        self.cache: Dict[str, Tuple[Any, float]] = {}
        
    def get_user(self, chat_id: int) -> UserState:
        return self.users[chat_id]
    
    def cache_get(self, key: str) -> Optional[Any]:
        if key in self.cache:
            value, timestamp = self.cache[key]
            if time.time() - timestamp < config.CACHE_TTL:
                return value
            del self.cache[key]
        return None
    
    def cache_set(self, key: str, value: Any):
        if len(self.cache) >= config.MAX_CACHE_SIZE:
            oldest_key = min(self.cache.keys(), key=lambda k: self.cache[k][1])
            del self.cache[oldest_key]
        self.cache[key] = (value, time.time())

bot_state = BotState()

class VietnamServices:
    """Services for Vietnam-specific features"""
    
    @staticmethod
    async def get_weather(city: str) -> str:
        """Get weather for Vietnamese cities"""
        if not config.WEATHER_API_KEY:
            return (
                "‚ùå Thi·∫øu API key th·ªùi ti·∫øt\n\n"
                "üí° B·∫°n c√≥ th·ªÉ xem th·ªùi ti·∫øt t·∫°i:\n"
                "‚Ä¢ nchmf.gov.vn (Trung t√¢m Kh√≠ t∆∞·ª£ng)\n"
                "‚Ä¢ weather.com\n"
                "‚Ä¢ windy.com"
            )
        
        city_info = VIETNAM_CITIES.get(city.lower())
        if not city_info:
            cities = ", ".join(VIETNAM_CITIES.keys())
            return f"‚ùå Kh√¥ng t√¨m th·∫•y {city}\n\nüìç C√°c th√†nh ph·ªë: {cities}"
        
        try:
            url = "https://api.openweathermap.org/data/2.5/weather"
            params = {
                "lat": city_info["lat"],
                "lon": city_info["lon"],
                "appid": config.WEATHER_API_KEY,
                "units": "metric",
                "lang": "vi"
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params, timeout=10) as response:
                    data = await response.json()
            
            temp = data["main"]["temp"]
            feels_like = data["main"]["feels_like"]
            humidity = data["main"]["humidity"]
            description = data["weather"][0]["description"]
            wind_speed = data.get("wind", {}).get("speed", 0)
            
            emoji = "‚òÄÔ∏è" if temp > 30 else "‚õÖ" if temp > 20 else "üåßÔ∏è"
            
            return (
                f"{emoji} **Th·ªùi ti·∫øt {city_info['name']}**\n\n"
                f"üå° Nhi·ªát ƒë·ªô: {temp}¬∞C (c·∫£m gi√°c {feels_like}¬∞C)\n"
                f"üíß ƒê·ªô ·∫©m: {humidity}%\n"
                f"üí® Gi√≥: {wind_speed} m/s\n"
                f"‚òÅÔ∏è M√¥ t·∫£: {description.capitalize()}\n\n"
                f"üí° {'Nh·ªõ mang √¥!' if 'm∆∞a' in description.lower() else 'Th·ªùi ti·∫øt ƒë·∫πp ƒë·ªÉ ƒëi ch∆°i!'}"
            )
        except Exception as e:
            logger.error(f"Weather error: {e}")
            return f"‚ùå L·ªói l·∫•y th·ªùi ti·∫øt: {str(e)[:100]}"
    
    @staticmethod
    async def get_exchange_rate() -> str:
        """Get USD/VND exchange rate"""
        try:
            url = "https://api.exchangerate-api.com/v4/latest/USD"
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=10) as response:
                    data = await response.json()
            
            vnd = data["rates"].get("VND", 0)
            eur = 1 / data["rates"].get("EUR", 1)
            gbp = 1 / data["rates"].get("GBP", 1)
            jpy = data["rates"].get("JPY", 0)
            cny = data["rates"].get("CNY", 0)
            
            return (
                f"üí± **T·ª∑ gi√° h√¥m nay**\n\n"
                f"üá∫üá∏ 1 USD = **{vnd:,.0f}** VND\n"
                f"üá™üá∫ 1 EUR = **{vnd * eur:,.0f}** VND\n"
                f"üá¨üáß 1 GBP = **{vnd * gbp:,.0f}** VND\n"
                f"üáØüáµ 100 JPY = **{vnd * 100 / jpy:,.0f}** VND\n"
                f"üá®üá≥ 1 CNY = **{vnd / cny:,.0f}** VND\n\n"
                f"üìä Ngu·ªìn: exchangerate-api.com"
            )
        except Exception as e:
            logger.error(f"Exchange rate error: {e}")
            return "‚ùå L·ªói l·∫•y t·ª∑ gi√°"
    
    @staticmethod
    def get_vietnam_time() -> str:
        """Get current time in Vietnam"""
        try:
            import pytz
            vn_tz = pytz.timezone('Asia/Ho_Chi_Minh')
            vn_time = datetime.datetime.now(vn_tz)
        except:
            vn_time = datetime.datetime.utcnow() + datetime.timedelta(hours=7)
        
        vn_days = ['Th·ª© Hai', 'Th·ª© Ba', 'Th·ª© T∆∞', 'Th·ª© NƒÉm', 'Th·ª© S√°u', 'Th·ª© B·∫£y', 'Ch·ªß Nh·∫≠t']
        day_name = vn_days[vn_time.weekday()]
        
        date_str = vn_time.strftime("%d-%m")
        holiday = VIETNAM_HOLIDAYS.get(date_str, "")
        
        time_str = (
            f"üáªüá≥ **Gi·ªù Vi·ªát Nam**\n\n"
            f"üìÖ {day_name}, {vn_time.strftime('%d/%m/%Y')}\n"
            f"üïê {vn_time.strftime('%H:%M:%S')} (GMT+7)"
        )
        
        if holiday:
            time_str += f"\n\nüéâ **{holiday}**"
        
        hour = vn_time.hour
        if 5 <= hour < 11:
            greeting = "üåÖ Ch√†o bu·ªïi s√°ng!"
        elif 11 <= hour < 13:
            greeting = "‚òÄÔ∏è Ch√†o bu·ªïi tr∆∞a!"
        elif 13 <= hour < 18:
            greeting = "üå§ Ch√†o bu·ªïi chi·ªÅu!"
        else:
            greeting = "üåô Ch√†o bu·ªïi t·ªëi!"
        
        time_str += f"\n\n{greeting}"
        return time_str
    
    @staticmethod
    async def get_news() -> str:
        """Get Vietnamese news"""
        if not config.NEWS_API_KEY:
            return (
                "üì∞ **B√°o ch√≠ Vi·ªát Nam**\n\n"
                "üì± **Tin t·ª©c t·ªïng h·ª£p:**\n"
                "‚Ä¢ VnExpress: vnexpress.net\n"
                "‚Ä¢ Tu·ªïi Tr·∫ª: tuoitre.vn\n"
                "‚Ä¢ Thanh Ni√™n: thanhnien.vn\n"
                "‚Ä¢ D√¢n Tr√≠: dantri.com.vn\n\n"
                "üíº **Kinh t·∫ø:**\n"
                "‚Ä¢ CafeF: cafef.vn\n"
                "‚Ä¢ VnEconomy: vneconomy.vn\n\n"
                "‚öΩ **Th·ªÉ thao:**\n"
                "‚Ä¢ Th·ªÉ Thao 247: thethao247.vn\n"
                "‚Ä¢ B√≥ng ƒê√° Plus: bongdaplus.vn"
            )
        
        try:
            url = "https://newsapi.org/v2/top-headlines"
            params = {
                "country": "vn",
                "apiKey": config.NEWS_API_KEY,
                "pageSize": 5
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params, timeout=10) as response:
                    data = await response.json()
            
            if data.get("status") != "ok":
                return "‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c tin t·ª©c"
            
            articles = data.get("articles", [])
            if not articles:
                return "üì∞ Kh√¥ng c√≥ tin m·ªõi"
            
            news_text = "üì∞ **Tin t·ª©c Vi·ªát Nam**\n\n"
            for i, article in enumerate(articles[:5], 1):
                title = article.get("title", "")
                desc = article.get("description", "")[:100]
                source = article.get("source", {}).get("name", "")
                
                news_text += f"**{i}. {title}**\n"
                if desc:
                    news_text += f"_{desc}..._\n"
                if source:
                    news_text += f"üìå {source}\n"
                news_text += "\n"
            
            return news_text
        except Exception as e:
            logger.error(f"News error: {e}")
            return "‚ùå L·ªói l·∫•y tin t·ª©c"

vietnam_services = VietnamServices()

class AIClient:
    """Handle AI text generation"""
    
    def __init__(self):
        self.client = None
        if config.VERCEL_API_KEY:
            self.client = OpenAI(
                api_key=config.VERCEL_API_KEY,
                base_url=config.BASE_URL,
                timeout=config.REQUEST_TIMEOUT
            )
    
    async def generate_image(self, prompt: str) -> Optional[bytes]:
        """Generate image using FLUX via Vercel API"""
        if not self.client:
            return None
        
        try:
            # Enhance prompt
            enhanced = f"{prompt}, masterpiece, high quality, detailed, 8k"
            
            response = await asyncio.to_thread(
                self.client.images.generate,
                model=config.IMAGE_GEN_MODEL,
                prompt=enhanced,
                n=1,
                size="1024x1024"
            )
            
            if response.data:
                image_url = response.data[0].url
                async with aiohttp.ClientSession() as session:
                    async with session.get(image_url, timeout=30) as resp:
                        if resp.status == 200:
                            return await resp.read()
                        
        except Exception as e:
            logger.error(f"Image generation error: {e}")
        
        return None
    
    def stream_complete(
        self,
        model: str,
        messages: List[Dict[str, str]],
        max_tokens: int,
        temperature: float = 0.7
    ):
        if not self.client:
            yield "‚ùå Thi·∫øu VERCEL_API_KEY"
            return
        
        try:
            stream = self.client.chat.completions.create(
                model=model,
                max_tokens=max_tokens,
                temperature=temperature,
                messages=messages,
                stream=True
            )
            
            for chunk in stream:
                if chunk.choices[0].delta.content:
                    yield chunk.choices[0].delta.content
                    
        except Exception as e:
            logger.error(f"Stream error: {e}")
            yield f"\n‚ùå L·ªói: {str(e)[:200]}"
    
    async def complete(
        self,
        model: str,
        messages: List[Dict[str, str]],
        max_tokens: int,
        temperature: float = 0.7,
        retries: int = 3
    ) -> str:
        if not self.client:
            return "‚ùå Thi·∫øu VERCEL_API_KEY"
        
        # Check cache
        cache_key = f"{model}:{json.dumps(messages)}:{max_tokens}:{temperature}"
        cached = bot_state.cache_get(cache_key)
        if cached:
            return cached
        
        last_error = None
        for attempt in range(retries):
            try:
                response = await asyncio.wait_for(
                    asyncio.to_thread(
                        self._sync_complete,
                        model, messages, max_tokens, temperature
                    ),
                    timeout=config.REQUEST_TIMEOUT + 10
                )
                
                bot_state.cache_set(cache_key, response)
                return response
                    
            except asyncio.TimeoutError:
                last_error = "Timeout"
            except Exception as e:
                last_error = str(e)
                
            if attempt < retries - 1:
                await asyncio.sleep(2 ** attempt + random.random())
        
        raise Exception(f"Failed after {retries} attempts: {last_error}")
    
    def _sync_complete(
        self, 
        model: str, 
        messages: List[Dict[str, str]], 
        max_tokens: int,
        temperature: float
    ) -> str:
        response = self.client.chat.completions.create(
            model=model,
            max_tokens=max_tokens,
            temperature=temperature,
            messages=messages
        )
        return (response.choices[0].message.content or "").strip()

ai_client = AIClient()

class TextProcessor:
    @staticmethod
    def chunk_text(text: str, max_length: int = 4096) -> List[str]:
        """Split text into chunks for Telegram"""
        if len(text) <= max_length:
            return [text]
        
        chunks = []
        lines = text.split('\n')
        current = ""
        
        for line in lines:
            if len(current) + len(line) + 1 > max_length:
                if current:
                    chunks.append(current)
                current = line[:max_length]
            else:
                current = current + '\n' + line if current else line
        
        if current:
            chunks.append(current)
        
        return chunks

text_processor = TextProcessor()

class FileProcessor:
    @staticmethod
    def detect_file_type(filename: str) -> FileType:
        name_lower = filename.lower()
        
        if any(name_lower.endswith(ext) for ext in ARCHIVES):
            return FileType.ARCHIVE
        elif any(name_lower.endswith(ext) for ext in CODE_EXTENSIONS):
            return FileType.CODE
        elif name_lower.endswith('.pdf'):
            return FileType.PDF
        elif name_lower.endswith(('.docx', '.doc')):
            return FileType.DOCX
        elif name_lower.endswith(('.xlsx', '.xls')):
            return FileType.XLSX
        elif name_lower.endswith(('.pptx', '.ppt')):
            return FileType.PPTX
        elif name_lower.endswith(('.html', '.htm')):
            return FileType.HTML
        elif name_lower.endswith('.json'):
            return FileType.JSON
        elif name_lower.endswith('.csv'):
            return FileType.CSV
        elif any(name_lower.endswith(ext) for ext in TEXT_LIKE):
            return FileType.TEXT
        else:
            return FileType.UNKNOWN
    
    @staticmethod
    def detect_encoding(data: bytes) -> str:
        if not data:
            return "utf-8"
        
        if chardet:
            result = chardet.detect(data)
            if result and result.get('encoding'):
                return result['encoding']
        
        for encoding in ['utf-8', 'utf-16', 'latin-1', 'cp1252', 'gb2312']:
            try:
                data.decode(encoding)
                return encoding
            except UnicodeDecodeError:
                continue
        
        return 'utf-8'
    
    @staticmethod
    async def process_file(filename: str, data: bytes) -> Tuple[Optional[str], str]:
        file_type = FileProcessor.detect_file_type(filename)
        
        try:
            if file_type == FileType.ARCHIVE:
                return None, "üì¶ File n√©n - gi·∫£i n√©n tr∆∞·ªõc khi g·ª≠i"
            
            elif file_type == FileType.PDF:
                if not PyPDF2:
                    return None, "‚ùå C·∫ßn c√†i PyPDF2 ƒë·ªÉ ƒë·ªçc PDF"
                return FileProcessor._read_pdf(data), "pdf"
            
            elif file_type == FileType.DOCX:
                if not docx:
                    return None, "‚ùå C·∫ßn c√†i python-docx ƒë·ªÉ ƒë·ªçc Word"
                return FileProcessor._read_docx(data), "docx"
            
            elif file_type == FileType.XLSX:
                if not openpyxl:
                    return None, "‚ùå C·∫ßn c√†i openpyxl ƒë·ªÉ ƒë·ªçc Excel"
                return FileProcessor._read_excel(data), "xlsx"
            
            elif file_type == FileType.PPTX:
                if not Presentation:
                    return None, "‚ùå C·∫ßn c√†i python-pptx ƒë·ªÉ ƒë·ªçc PowerPoint"
                return FileProcessor._read_pptx(data), "pptx"
            
            elif file_type == FileType.HTML:
                text = FileProcessor._decode_text(data)
                if BeautifulSoup:
                    soup = BeautifulSoup(text, 'html.parser')
                    return soup.get_text(separator='\n'), "html"
                return text, "html"
            
            elif file_type == FileType.JSON:
                text = FileProcessor._decode_text(data)
                try:
                    obj = json.loads(text)
                    return json.dumps(obj, indent=2, ensure_ascii=False), "json"
                except:
                    return text, "json"
            
            elif file_type in [FileType.TEXT, FileType.CODE, FileType.CSV]:
                return FileProcessor._decode_text(data), file_type.value
            
            else:
                return None, f"‚ùå File {filename} kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£"
                
        except Exception as e:
            logger.error(f"File processing error: {e}")
            return None, f"‚ùå L·ªói: {str(e)[:100]}"
    
    @staticmethod
    def _decode_text(data: bytes) -> str:
        encoding = FileProcessor.detect_encoding(data)
        try:
            return data.decode(encoding, errors='ignore')
        except:
            return data.decode('utf-8', errors='ignore')
    
    @staticmethod
    def _read_pdf(data: bytes) -> str:
        pdf_file = io.BytesIO(data)
        pdf_reader = PyPDF2.PdfReader(pdf_file)
        text = []
        for page in pdf_reader.pages:
            text.append(page.extract_text())
        return '\n'.join(text)
    
    @staticmethod
    def _read_docx(data: bytes) -> str:
        doc_file = io.BytesIO(data)
        doc = DocxDocument(doc_file)
        return '\n'.join([p.text for p in doc.paragraphs])
    
    @staticmethod
    def _read_excel(data: bytes) -> str:
        excel_file = io.BytesIO(data)
        wb = openpyxl.load_workbook(excel_file, read_only=True)
        text = []
        for sheet_name in wb.sheetnames:
            sheet = wb[sheet_name]
            text.append(f"=== Sheet: {sheet_name} ===")
            for row in sheet.iter_rows(values_only=True):
                row_text = '\t'.join([str(cell) if cell else '' for cell in row])
                if row_text.strip():
                    text.append(row_text)
        return '\n'.join(text)
    
    @staticmethod
    def _read_pptx(data: bytes) -> str:
        pptx_file = io.BytesIO(data)
        prs = Presentation(pptx_file)
        text = []
        for i, slide in enumerate(prs.slides, 1):
            text.append(f"=== Slide {i} ===")
            for shape in slide.shapes:
                if hasattr(shape, "text") and shape.text.strip():
                    text.append(shape.text)
        return '\n'.join(text)

file_processor = FileProcessor()

class MessageBuilder:
    @staticmethod
    def build_system_prompt(context_type: str = "chat") -> str:
        try:
            import pytz
            vn_tz = pytz.timezone('Asia/Ho_Chi_Minh')
            vn_time = datetime.datetime.now(vn_tz)
        except:
            vn_time = datetime.datetime.utcnow() + datetime.timedelta(hours=7)
        
        time_str = vn_time.strftime('%d/%m/%Y %H:%M:%S')
        
        base = (
            f"B·∫°n l√† Linh - AI Assistant th√¥ng minh c·ªßa Vi·ªát Nam.\n"
            f"Th·ªùi gian: {time_str}\n"
            f"Developer: @cucodoivandep\n\n"
        )
        
        if context_type == "chat":
            return base + (
                "Ki·∫øn th·ª©c:\n"
                "‚Ä¢ VƒÉn h√≥a, l·ªãch s·ª≠, ƒë·ªãa l√Ω Vi·ªát Nam\n"
                "‚Ä¢ ·∫®m th·ª±c, du l·ªãch Vi·ªát Nam\n"
                "‚Ä¢ C√¥ng ngh·ªá, khoa h·ªçc\n\n"
                "Phong c√°ch:\n"
                "‚Ä¢ Th√¢n thi·ªán, vui v·∫ª\n"
                "‚Ä¢ Tr·∫£ l·ªùi ng·∫Øn g·ªçn, ch√≠nh x√°c\n"
                "‚Ä¢ D√πng emoji ph√π h·ª£p\n"
                "‚Ä¢ ∆Øu ti√™n th√¥ng tin v·ªÅ Vi·ªát Nam"
            )
        
        elif context_type == "code":
            return base + (
                "B·∫°n l√† l·∫≠p tr√¨nh vi√™n chuy√™n nghi·ªáp.\n\n"
                "Nguy√™n t·∫Øc:\n"
                "‚Ä¢ Code clean, optimal\n"
                "‚Ä¢ Comment r√µ r√†ng\n"
                "‚Ä¢ Best practices\n"
                "‚Ä¢ X·ª≠ l√Ω errors ƒë·∫ßy ƒë·ªß"
            )
        
        elif context_type == "file":
            return base + (
                "X·ª≠ l√Ω file chuy√™n nghi·ªáp.\n\n"
                "Tasks:\n"
                "‚Ä¢ Ph√¢n t√≠ch n·ªôi dung\n"
                "‚Ä¢ T√≥m t·∫Øt key points\n"
                "‚Ä¢ Tr·∫£ l·ªùi c√¢u h·ªèi\n"
                "‚Ä¢ ƒê·ªÅ xu·∫•t c·∫£i thi·ªán"
            )
        
        return base
    
    @staticmethod
    def build_messages(
        chat_id: int,
        user_text: str,
        context_type: str = "chat",
        include_history: bool = True
    ) -> List[Dict[str, str]]:
        messages = []
        
        # System prompt
        messages.append({
            "role": "system",
            "content": MessageBuilder.build_system_prompt(context_type)
        })
        
        # History
        if include_history:
            user = bot_state.get_user(chat_id)
            keep_turns = config.CTX_TURNS * 2
            
            for role, content in list(user.history)[-keep_turns:]:
                truncated = content[:500] + "..." if len(content) > 500 else content
                messages.append({
                    "role": "user" if role == "user" else "assistant",
                    "content": truncated
                })
        
        # Current message
        messages.append({"role": "user", "content": user_text})
        
        return messages

message_builder = MessageBuilder()

async def stream_response(
    context: ContextTypes.DEFAULT_TYPE,
    chat_id: int,
    model: str,
    messages: List[Dict[str, str]],
    max_tokens: int,
    temperature: float = 0.7
):
    """Stream AI response with live updates"""
    msg = await context.bot.send_message(chat_id, "üí≠ ƒêang suy nghƒ©...")
    
    full_response = ""
    buffer = ""
    counter = 0
    
    async def update_message():
        nonlocal buffer
        try:
            if buffer:
                await msg.edit_text(buffer[:4096])
        except:
            pass
    
    try:
        stream = await asyncio.to_thread(
            ai_client.stream_complete,
            model, messages, max_tokens, temperature
        )
        
        for chunk in stream:
            full_response += chunk
            buffer += chunk
            counter += 1
            
            # Update every 5 chunks
            if counter % 5 == 0 and len(buffer) > 100:
                await update_message()
        
        # Final update
        if full_response:
            chunks = text_processor.chunk_text(full_response)
            
            if len(chunks) == 1:
                await msg.edit_text(chunks[0])
            else:
                await msg.delete()
                for i, chunk in enumerate(chunks, 1):
                    await context.bot.send_message(
                        chat_id,
                        f"üìÑ Ph·∫ßn {i}/{len(chunks)}:\n\n{chunk}"
                    )
        
        return full_response
        
    except Exception as e:
        logger.error(f"Stream response error: {e}")
        await msg.edit_text(f"‚ùå L·ªói: {str(e)[:200]}")
        return None

# Command Handlers
async def cmd_help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = """
üáªüá≥ **LINH AI - TR·ª¢ L√ù VI·ªÜT NAM**

üìù **L·ªánh c∆° b·∫£n:**
‚Ä¢ /help - H∆∞·ªõng d·∫´n
‚Ä¢ /start - Kh·ªüi ƒë·ªông
‚Ä¢ /clear - X√≥a l·ªãch s·ª≠
‚Ä¢ /stats - Th·ªëng k√™

üíª **AI Features:**
‚Ä¢ /code <y√™u c·∫ßu> - Vi·∫øt code
‚Ä¢ /img <m√¥ t·∫£> - T·∫°o ·∫£nh AI
‚Ä¢ Chat tr·ª±c ti·∫øp ƒë·ªÉ h·ªèi ƒë√°p

üáªüá≥ **Vi·ªát Nam:**
‚Ä¢ /weather <city> - Th·ªùi ti·∫øt
‚Ä¢ /news - Tin t·ª©c
‚Ä¢ /exchange - T·ª∑ gi√°
‚Ä¢ /time - Gi·ªù Vi·ªát Nam
‚Ä¢ /translate <text> - D·ªãch Anh-Vi·ªát

üìÑ **File:**
‚Ä¢ G·ª≠i file ƒë·ªÉ x·ª≠ l√Ω (PDF, Word, Excel...)
‚Ä¢ /sendfile - T·∫£i k·∫øt qu·∫£
‚Ä¢ /cancelfile - H·ªßy file mode

üí° **Tips:**
‚Ä¢ img: <prompt> - T·∫°o ·∫£nh nhanh
‚Ä¢ H·ªèi v·ªÅ vƒÉn h√≥a, ·∫©m th·ª±c, du l·ªãch VN

‚öôÔ∏è **Models:**
‚Ä¢ Chat: Claude-3.5-Haiku
‚Ä¢ Code: Claude-3.5-Sonnet
‚Ä¢ Image: FLUX-Schnell

üë®‚Äçüíª Dev: @cucodoivandep
    """
    
    await context.bot.send_message(
        update.effective_chat.id,
        help_text,
        parse_mode=ParseMode.MARKDOWN
    )

async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    welcome = """
üáªüá≥ **Xin ch√†o! M√¨nh l√† Linh - AI Assistant Vi·ªát Nam**

üéØ **M√¨nh c√≥ th·ªÉ gi√∫p:**
‚Ä¢ üí¨ Chat, t∆∞ v·∫•n m·ªçi ch·ªß ƒë·ªÅ
‚Ä¢ üíª Vi·∫øt code, debug
‚Ä¢ üé® T·∫°o ·∫£nh t·ª´ text
‚Ä¢ üìÑ X·ª≠ l√Ω file, documents
‚Ä¢ üáªüá≥ Th√¥ng tin Vi·ªát Nam

üí° **Th·ª≠ ngay:**
‚Ä¢ H·ªèi v·ªÅ l·ªãch s·ª≠, vƒÉn h√≥a VN
‚Ä¢ /img phong c·∫£nh H·∫° Long
‚Ä¢ /code vi·∫øt game Python

Ch√∫c b·∫°n m·ªôt ng√†y t·ªët l√†nh! üå∫
    """
    
    keyboard = InlineKeyboardMarkup([
        [
            InlineKeyboardButton("üìñ H∆∞·ªõng d·∫´n", callback_data="help"),
            InlineKeyboardButton("üáªüá≥ V·ªÅ VN", callback_data="vietnam")
        ],
        [
            InlineKeyboardButton("üí¨ B·∫Øt ƒë·∫ßu chat", callback_data="chat")
        ]
    ])
    
    await context.bot.send_message(
        update.effective_chat.id,
        welcome,
        parse_mode=ParseMode.MARKDOWN,
        reply_markup=keyboard
    )

async def cmd_img(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Generate image from text"""
    chat_id = update.effective_chat.id
    prompt = " ".join(context.args).strip()
    
    if not prompt:
        examples = [
            "v·ªãnh H·∫° Long l√∫c ho√†ng h√¥n",
            "ph·ªü b√≤ H√† N·ªôi",
            "√°o d√†i Vi·ªát Nam",
            "ph·ªë c·ªï H·ªôi An",
            "ru·ªông b·∫≠c thang Sapa"
        ]
        
        await context.bot.send_message(
            chat_id,
            "üé® **T·∫°o ·∫£nh AI**\n\n"
            f"C√∫ ph√°p: /img <m√¥ t·∫£>\n\n"
            f"**V√≠ d·ª•:**\n" + "\n".join([f"‚Ä¢ /img {e}" for e in examples]),
            parse_mode=ParseMode.MARKDOWN
        )
        return
    
    if not config.VERCEL_API_KEY:
        await context.bot.send_message(
            chat_id,
            "‚ùå C·∫ßn VERCEL_API_KEY ƒë·ªÉ t·∫°o ·∫£nh"
        )
        return
    
    # Send typing action
    await context.bot.send_chat_action(chat_id=chat_id, action=ChatAction.UPLOAD_PHOTO)
    
    # Status message
    status = await context.bot.send_message(
        chat_id,
        f"üé® ƒêang t·∫°o: _{prompt}_\n‚è≥ Vui l√≤ng ch·ªù 10-30 gi√¢y...",
        parse_mode=ParseMode.MARKDOWN
    )
    
    try:
        # Generate image
        image_data = await ai_client.generate_image(prompt)
        
        if image_data:
            await status.delete()
            await context.bot.send_photo(
                chat_id,
                photo=io.BytesIO(image_data),
                caption=f"üé® {prompt}\n\nüí° M·∫πo: D√πng 'img: {prompt}' ƒë·ªÉ t·∫°o nhanh"
            )
            
            # Save to history
            user = bot_state.get_user(chat_id)
            user.history.append(("user", f"/img {prompt}"))
            user.history.append(("assistant", f"ƒê√£ t·∫°o ·∫£nh: {prompt}"))
        else:
            await status.edit_text(
                "‚ùå Kh√¥ng th·ªÉ t·∫°o ·∫£nh\n\n"
                "üí° Th·ª≠:\n"
                "‚Ä¢ M√¥ t·∫£ chi ti·∫øt h∆°n\n"
                "‚Ä¢ D√πng ti·∫øng Anh\n"
                "‚Ä¢ Tr√°nh n·ªôi dung nh·∫°y c·∫£m"
            )
            
    except Exception as e:
        logger.error(f"Image generation error: {e}")
        await status.edit_text(f"‚ùå L·ªói: {str(e)[:100]}")

async def cmd_code(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Generate code"""
    chat_id = update.effective_chat.id
    request = " ".join(context.args).strip()
    
    if not request:
        examples = [
            "game snake Python",
            "validate email regex",
            "REST API Flask",
            "React todo app",
            "quicksort C++"
        ]
        
        await context.bot.send_message(
            chat_id,
            "üíª **Vi·∫øt Code**\n\n"
            f"C√∫ ph√°p: /code <y√™u c·∫ßu>\n\n"
            f"**V√≠ d·ª•:**\n" + "\n".join([f"‚Ä¢ /code {e}" for e in examples]),
            parse_mode=ParseMode.MARKDOWN
        )
        return
    
    await context.bot.send_chat_action(chat_id=chat_id, action=ChatAction.TYPING)
    
    # Build messages
    messages = message_builder.build_messages(
        chat_id,
        request,
        context_type="code",
        include_history=False
    )
    
    # Generate
    result = await stream_response(
        context,
        chat_id,
        config.CODE_MODEL,
        messages,
        config.MAX_TOKENS_CODE,
        temperature=0.3
    )
    
    if result:
        user = bot_state.get_user(chat_id)
        user.last_result = result
        user.history.append(("user", f"/code {request}"))
        user.history.append(("assistant", result[:500]))

async def cmd_clear(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Clear user data"""
    chat_id = update.effective_chat.id
    user = bot_state.get_user(chat_id)
    
    user.history.clear()
    user.file_mode = False
    user.pending_file = None
    user.last_result = ""
    
    await context.bot.send_message(
        chat_id,
        "‚úÖ **ƒê√£ x√≥a:**\n"
        "‚Ä¢ L·ªãch s·ª≠ chat\n"
        "‚Ä¢ File l∆∞u\n"
        "‚Ä¢ K·∫øt qu·∫£"
    )

async def cmd_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Show statistics"""
    chat_id = update.effective_chat.id
    user = bot_state.get_user(chat_id)
    
    vn_time = vietnam_services.get_vietnam_time()
    
    stats = f"""
üìä **Th·ªëng k√™**

üë§ User: {update.effective_user.first_name}
üÜî ID: `{chat_id}`
üí¨ L·ªãch s·ª≠: {len(user.history)} tin
üìÅ File mode: {'B·∫≠t' if user.file_mode else 'T·∫Øt'}

‚öôÔ∏è **Models:**
‚Ä¢ Chat: {config.CHAT_MODEL}
‚Ä¢ Code: {config.CODE_MODEL}

{vn_time}
    """
    
    await context.bot.send_message(
        chat_id,
        stats,
        parse_mode=ParseMode.MARKDOWN
    )

async def cmd_weather(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Get weather"""
    chat_id = update.effective_chat.id
    
    if not context.args:
        cities = ", ".join(VIETNAM_CITIES.keys())
        await context.bot.send_message(
            chat_id,
            f"‚òÄÔ∏è **Th·ªùi ti·∫øt**\n\n"
            f"C√∫ ph√°p: /weather <city>\n\n"
            f"Cities: {cities}",
            parse_mode=ParseMode.MARKDOWN
        )
        return
    
    city = context.args[0]
    weather = await vietnam_services.get_weather(city)
    
    await context.bot.send_message(
        chat_id,
        weather,
        parse_mode=ParseMode.MARKDOWN
    )

async def cmd_exchange(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Get exchange rates"""
    chat_id = update.effective_chat.id
    rates = await vietnam_services.get_exchange_rate()
    
    await context.bot.send_message(
        chat_id,
        rates,
        parse_mode=ParseMode.MARKDOWN
    )

async def cmd_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Get Vietnam time"""
    chat_id = update.effective_chat.id
    time_info = vietnam_services.get_vietnam_time()
    
    await context.bot.send_message(
        chat_id,
        time_info,
        parse_mode=ParseMode.MARKDOWN
    )

async def cmd_news(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Get news"""
    chat_id = update.effective_chat.id
    news = await vietnam_services.get_news()
    
    await context.bot.send_message(
        chat_id,
        news,
        parse_mode=ParseMode.MARKDOWN
    )

async def cmd_translate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Translate English to Vietnamese"""
    chat_id = update.effective_chat.id
    text = " ".join(context.args).strip()
    
    if not text:
        await context.bot.send_message(
            chat_id,
            "üî§ **D·ªãch Anh-Vi·ªát**\n\n"
            "C√∫ ph√°p: /translate <text>",
            parse_mode=ParseMode.MARKDOWN
        )
        return
    
    messages = [
        {"role": "system", "content": "D·ªãch sang ti·∫øng Vi·ªát t·ª± nhi√™n, ch√≠nh x√°c."},
        {"role": "user", "content": f"Translate to Vietnamese:\n{text}"}
    ]
    
    result = await ai_client.complete(
        config.CHAT_MODEL,
        messages,
        500,
        temperature=0.3
    )
    
    await context.bot.send_message(
        chat_id,
        f"üî§ **Original:**\n{text}\n\n"
        f"üáªüá≥ **Ti·∫øng Vi·ªát:**\n{result}",
        parse_mode=ParseMode.MARKDOWN
    )

async def cmd_sendfile(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send last result as file"""
    chat_id = update.effective_chat.id
    user = bot_state.get_user(chat_id)
    
    if not user.last_result:
        await context.bot.send_message(
            chat_id,
            "‚ùå Kh√¥ng c√≥ k·∫øt qu·∫£"
        )
        return
    
    file_io = io.BytesIO(user.last_result.encode('utf-8'))
    file_io.name = f"result_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
    
    await context.bot.send_document(
        chat_id,
        document=file_io,
        caption="üìÑ K·∫øt qu·∫£"
    )

async def cmd_cancelfile(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancel file mode"""
    chat_id = update.effective_chat.id
    user = bot_state.get_user(chat_id)
    
    user.file_mode = False
    user.pending_file = None
    
    await context.bot.send_message(
        chat_id,
        "‚úÖ ƒê√£ tho√°t file mode"
    )

# Message Handlers
async def on_file(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle file uploads"""
    chat_id = update.effective_chat.id
    document = update.message.document
    
    if not document:
        return
    
    if document.file_size > 20 * 1024 * 1024:
        await context.bot.send_message(
            chat_id,
            "‚ùå File qu√° l·ªõn (max 20MB)"
        )
        return
    
    await context.bot.send_chat_action(chat_id=chat_id, action=ChatAction.TYPING)
    
    try:
        # Download file
        file = await context.bot.get_file(document.file_id)
        file_data = await file.download_as_bytearray()
        
        # Process file
        content, file_type = await file_processor.process_file(
            document.file_name or "unknown",
            bytes(file_data)
        )
        
        if not content:
            await context.bot.send_message(chat_id, file_type)
            return
        
        # Save to user state
        user = bot_state.get_user(chat_id)
        user.file_mode = True
        user.pending_file = {
            "name": document.file_name,
            "content": content[:config.CHUNK_CHARS],
            "type": file_type
        }
        
        # Preview
        preview = content[:500] + "..." if len(content) > 500 else content
        
        await context.bot.send_message(
            chat_id,
            f"‚úÖ **File nh·∫≠n ƒë∆∞·ª£c**\n\n"
            f"üìÑ T√™n: {document.file_name}\n"
            f"üìä Lo·∫°i: {file_type}\n"
            f"üìù Size: {len(content):,} k√Ω t·ª±\n\n"
            f"**Preview:**\n```\n{preview}\n```\n\n"
            f"üí¨ H·ªèi v·ªÅ file ho·∫∑c /cancelfile",
            parse_mode=ParseMode.MARKDOWN
        )
        
    except Exception as e:
        logger.error(f"File handling error: {e}")
        await context.bot.send_message(
            chat_id,
            f"‚ùå L·ªói: {str(e)[:100]}"
        )

async def on_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle text messages"""
    chat_id = update.effective_chat.id
    text = (update.message.text or "").strip()
    
    if not text:
        return
    
    # Quick image generation
    if text.lower().startswith("img:"):
        prompt = text[4:].strip()
        context.args = prompt.split()
        await cmd_img(update, context)
        return
    
    user = bot_state.get_user(chat_id)
    
    await context.bot.send_chat_action(chat_id=chat_id, action=ChatAction.TYPING)
    
    # File mode
    if user.file_mode and user.pending_file:
        file_info = user.pending_file
        prompt = (
            f"File: {file_info['name']}\n"
            f"Content:\n{file_info['content'][:10000]}\n\n"
            f"Question: {text}"
        )
        
        messages = message_builder.build_messages(
            chat_id,
            prompt,
            context_type="file",
            include_history=False
        )
        
        result = await stream_response(
            context,
            chat_id,
            config.FILE_MODEL,
            messages,
            config.FILE_OUTPUT_TOKENS,
            temperature=0.5
        )
    else:
        # Normal chat
        messages = message_builder.build_messages(
            chat_id,
            text,
            context_type="chat",
            include_history=True
        )
        
        result = await stream_response(
            context,
            chat_id,
            config.CHAT_MODEL,
            messages,
            config.MAX_TOKENS,
            temperature=0.7
        )
    
    if result:
        user.last_result = result
        user.history.append(("user", text[:500]))
        user.history.append(("assistant", result[:500]))

async def on_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle callback queries"""
    query = update.callback_query
    await query.answer()
    
    if query.data == "help":
        await cmd_help(update, context)
    
    elif query.data == "vietnam":
        info = """
üáªüá≥ **VI·ªÜT NAM T√îI Y√äU**

üèõ **L·ªãch s·ª≠:**
‚Ä¢ 4000 nƒÉm vƒÉn hi·∫øn
‚Ä¢ Kinh ƒë√¥: ThƒÉng Long - H√† N·ªôi
‚Ä¢ ƒê·ªôc l·∫≠p: 2/9/1945

üåè **ƒê·ªãa l√Ω:**
‚Ä¢ Di·ªán t√≠ch: 331,212 km¬≤
‚Ä¢ D√¢n s·ªë: ~98 tri·ªáu
‚Ä¢ 63 t·ªânh th√†nh

üé≠ **VƒÉn h√≥a:**
‚Ä¢ 54 d√¢n t·ªôc
‚Ä¢ 8 Di s·∫£n UNESCO
‚Ä¢ ·∫®m th·ª±c phong ph√∫

üèÜ **Th√†nh t·ª±u:**
‚Ä¢ Top 20 kinh t·∫ø th·∫ø gi·ªõi
‚Ä¢ Xu·∫•t kh·∫©u g·∫°o s·ªë 2
‚Ä¢ Du l·ªãch ph√°t tri·ªÉn

üí™ Vi·ªát Nam - V∆∞∆°n t·∫ßm th·∫ø gi·ªõi!
        """
        await context.bot.send_message(
            query.message.chat_id,
            info,
            parse_mode=ParseMode.MARKDOWN
        )
    
    elif query.data == "chat":
        await context.bot.send_message(
            query.message.chat_id,
            "üí¨ S·∫µn s√†ng! H√£y chat v·ªõi m√¨nh nh√©.\n\n"
            "üí° Th·ª≠ h·ªèi v·ªÅ:\n"
            "‚Ä¢ L·ªãch s·ª≠, vƒÉn h√≥a VN\n"
            "‚Ä¢ ·∫®m th·ª±c, du l·ªãch\n"
            "‚Ä¢ L·∫≠p tr√¨nh, c√¥ng ngh·ªá"
        )

def main():
    if not config.BOT_TOKEN:
        print("‚ùå Missing BOT_TOKEN")
        return
    
    print("=" * 50)
    print("üáªüá≥ LINH BOT - AI Assistant Vietnam")
    print("=" * 50)
    
    if not config.VERCEL_API_KEY:
        print("‚ö†Ô∏è  No VERCEL_API_KEY - Limited features")
    else:
        print("‚úÖ Vercel API: Ready")
    
    print("=" * 50)
    
    app = ApplicationBuilder().token(config.BOT_TOKEN).build()
    
    # Commands
    app.add_handler(CommandHandler("start", cmd_start))
    app.add_handler(CommandHandler("help", cmd_help))
    app.add_handler(CommandHandler("clear", cmd_clear))
    app.add_handler(CommandHandler("stats", cmd_stats))
    app.add_handler(CommandHandler("img", cmd_img))
    app.add_handler(CommandHandler("code", cmd_code))
    app.add_handler(CommandHandler("weather", cmd_weather))
    app.add_handler(CommandHandler("news", cmd_news))
    app.add_handler(CommandHandler("exchange", cmd_exchange))
    app.add_handler(CommandHandler("time", cmd_time))
    app.add_handler(CommandHandler("translate", cmd_translate))
    app.add_handler(CommandHandler("sendfile", cmd_sendfile))
    app.add_handler(CommandHandler("cancelfile", cmd_cancelfile))
    
    # Callbacks
    app.add_handler(CallbackQueryHandler(on_callback))
    
    # Messages
    app.add_handler(MessageHandler(filters.Document.ALL, on_file))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, on_text))
    
    print("üöÄ Bot running...")
    print("üí¨ Chat: Claude-3.5")
    print("üé® Image: FLUX via Vercel")
    print("üë®‚Äçüíª Dev: @cucodoivandep")
    print("=" * 50)
    
    app.run_polling(drop_pending_updates=True)

if __name__ == "__main__":
    main()
