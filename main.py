import os
import random
import asyncio
import logging
import requests
import json
import sqlite3
import gc
from datetime import datetime, timedelta, time
from typing import Dict, List, Optional, Tuple
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters

BOT_TOKEN = os.environ["BOT_TOKEN"]
VERCEL_API_KEY = os.environ.get("VERCEL_API_KEY", "")
BASE_URL = os.getenv("BASE_URL", "https://ai-gateway.vercel.sh/v1")
CHAT_MODEL = os.getenv("CHAT_MODEL", "openai/gpt-oss-120b")
CLAUDE_MODEL = "anthropic/claude-3.5-sonnet"
MAX_TOKENS = int(os.getenv("MAX_TOKENS", "400"))
CTX_TURNS = int(os.getenv("CTX_TURNS", "3"))

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

def init_db():
    conn = sqlite3.connect('bot_scores.db')
    c = conn.cursor()
    c.execute('''
        CREATE TABLE IF NOT EXISTS scores (
            user_id INTEGER,
            username TEXT,
            game_type TEXT,
            score INTEGER,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    c.execute('''
        CREATE TABLE IF NOT EXISTS chats (
            chat_id INTEGER PRIMARY KEY,
            chat_type TEXT,
            title TEXT
        )
    ''')
    conn.commit()
    conn.close()

init_db()

active_games: Dict[int, dict] = {}
chat_history: Dict[int, List[dict]] = {}
quiz_sessions: Dict[int, dict] = {}
quiz_mode: Dict[int, bool] = {}
quiz_count: Dict[int, int] = {}
quiz_history: Dict[int, List[str]] = {}
word_game_sessions: Dict[int, dict] = {}
goodnight_task = None

def save_chat_info(chat_id: int, chat_type: str, title: str = None):
    conn = sqlite3.connect('bot_scores.db')
    c = conn.cursor()
    c.execute('INSERT OR REPLACE INTO chats (chat_id, chat_type, title) VALUES (?, ?, ?)',
              (chat_id, chat_type, title))
    conn.commit()
    conn.close()

def get_all_chats():
    conn = sqlite3.connect('bot_scores.db')
    c = conn.cursor()
    c.execute('SELECT chat_id, chat_type FROM chats')
    results = c.fetchall()
    conn.close()
    return results

def cleanup_memory():
    global chat_history, quiz_history
    for chat_id in list(chat_history.keys()):
        if len(chat_history[chat_id]) > 4:
            chat_history[chat_id] = chat_history[chat_id][-4:]
    
    for chat_id in list(quiz_history.keys()):
        if len(quiz_history[chat_id]) > 20:
            quiz_history[chat_id] = quiz_history[chat_id][-20:]
    
    gc.collect()

def save_score(user_id: int, username: str, game_type: str, score: int):
    try:
        conn = sqlite3.connect('bot_scores.db')
        c = conn.cursor()
        c.execute('INSERT INTO scores (user_id, username, game_type, score) VALUES (?, ?, ?, ?)',
                  (user_id, username, game_type, score))
        conn.commit()
        conn.close()
    except Exception as e:
        logger.error(f"Save score error: {e}")

def get_leaderboard_24h(limit: int = 10) -> List[tuple]:
    try:
        conn = sqlite3.connect('bot_scores.db')
        c = conn.cursor()
        yesterday = datetime.now() - timedelta(days=1)
        c.execute('''
            SELECT username, SUM(score) as total_score, COUNT(DISTINCT game_type) as games_played
            FROM scores
            WHERE timestamp >= ?
            GROUP BY user_id
            ORDER BY total_score DESC
            LIMIT ?
        ''', (yesterday, limit))
        results = c.fetchall()
        conn.close()
        return results
    except Exception as e:
        logger.error(f"Get leaderboard error: {e}")
        return []

def get_user_stats_24h(user_id: int) -> dict:
    try:
        conn = sqlite3.connect('bot_scores.db')
        c = conn.cursor()
        yesterday = datetime.now() - timedelta(days=1)
        
        c.execute('''
            SELECT game_type, COUNT(*) as games_played, SUM(score) as total_score, MAX(score) as best_score
            FROM scores
            WHERE user_id = ? AND timestamp >= ?
            GROUP BY game_type
        ''', (user_id, yesterday))
        results = c.fetchall()
        
        stats = {'total': 0, 'games': {}}
        
        for game_type, games_played, total_score, best_score in results:
            stats['games'][game_type] = {
                'played': games_played,
                'total': total_score,
                'best': best_score
            }
            stats['total'] += total_score
            
        conn.close()
        return stats
    except Exception as e:
        logger.error(f"Get stats error: {e}")
        return {'total': 0, 'games': {}}

class GuessNumberGame:
    def __init__(self, chat_id: int):
        self.chat_id = chat_id
        self.attempts = 0
        self.max_attempts = 10
        self.hints_used = 0
        self.max_hints = 3
        self.start_time = datetime.now()
        self.score = 1000
        self.secret_number = random.randint(1, 100)
        self.riddle = self.generate_riddle()
            
    def generate_riddle(self) -> str:
        riddles = []
        if self.secret_number % 2 == 0:
            riddles.append("s·ªë ch·∫µn")
        else:
            riddles.append("s·ªë l·∫ª")
        if self.secret_number < 50:
            riddles.append("nh·ªè h∆°n 50")
        else:
            riddles.append("l·ªõn h∆°n ho·∫∑c b·∫±ng 50")
        return f"S·ªë b√≠ m·∫≠t l√† {' v√† '.join(riddles)}"
        
    def get_hint(self) -> str:
        if self.hints_used >= self.max_hints:
            return "‚ùå H·∫øt g·ª£i √Ω r·ªìi!"
            
        self.hints_used += 1
        self.score -= 100
        
        if self.hints_used == 1:
            tens = self.secret_number // 10
            hint = f"üí° G·ª£i √Ω 1: {'S·ªë c√≥ 1 ch·ªØ s·ªë' if tens == 0 else f'Ch·ªØ s·ªë h√†ng ch·ª•c l√† {tens}'}"
        elif self.hints_used == 2:
            digit_sum = sum(int(d) for d in str(self.secret_number))
            hint = f"üí° G·ª£i √Ω 2: T·ªïng c√°c ch·ªØ s·ªë l√† {digit_sum}"
        else:
            lower = (self.secret_number // 10) * 10
            upper = lower + 9 if lower > 0 else 9
            hint = f"üí° G·ª£i √Ω 3: S·ªë t·ª´ {max(1, lower)} ƒë·∫øn {upper}"
        return f"{hint}\nüéØ C√≤n {self.max_hints - self.hints_used} g·ª£i √Ω"
        
    def make_guess(self, guess: int) -> Tuple[bool, str]:
        self.attempts += 1
        self.score -= 50
        
        if guess == self.secret_number:
            time_taken = (datetime.now() - self.start_time).seconds
            final_score = max(self.score, 100)
            return True, f"üéâ ƒê√∫ng r·ªìi! S·ªë {self.secret_number}!\n‚è±Ô∏è {time_taken}s | üèÜ {final_score} ƒëi·ªÉm"
            
        if self.attempts >= self.max_attempts:
            return True, f"üò§ H·∫øt l∆∞·ª£t! S·ªë l√† {self.secret_number}\nüí° {self.riddle}"
            
        hint = "üìà cao h∆°n" if guess < self.secret_number else "üìâ th·∫•p h∆°n"
        remaining = self.max_attempts - self.attempts
        return False, f"{guess} {hint}! C√≤n {remaining} l∆∞·ª£t | üí∞ {self.score}ƒë | /hint"

class VuaTiengVietGame:
    def __init__(self, chat_id: int):
        self.chat_id = chat_id
        self.current_word = ""
        self.scrambled = ""
        self.attempts = 0
        self.max_attempts = 3
        self.score = 0
        self.start_time = datetime.now()
        self.round_count = 0
        self.difficulty_level = 1
        
    async def start_new_round(self) -> str:
        self.round_count += 1
        self.attempts = 0
        
        if self.round_count % 3 == 0:
            self.difficulty_level = min(self.difficulty_level + 1, 3)
        
        await asyncio.sleep(5)
        
        self.current_word, self.scrambled = await self.generate_word_puzzle()
        
        difficulty_text = ["D·ªÑ", "TRUNG B√åNH", "KH√ì"][self.difficulty_level - 1]
        
        return f"""üéÆ **VUA TI·∫æNG VI·ªÜT - C√ÇU {self.round_count}**
üìä ƒê·ªô kh√≥: **{difficulty_text}**

S·∫Øp x·∫øp c√°c k√Ω t·ª± sau th√†nh t·ª´/c·ª•m t·ª´ c√≥ nghƒ©a:

üî§ **{self.scrambled}**

üí° G·ª£i √Ω: {len(self.current_word.replace(' ', ''))} ch·ªØ c√°i
üìù B·∫°n c√≥ {self.max_attempts} l·∫ßn th·ª≠

G√µ ƒë√°p √°n c·ªßa b·∫°n!"""

    async def generate_word_puzzle(self) -> Tuple[str, str]:
        difficulty_words = {
            1: [
                "h·ªçc sinh", "gi√°o vi√™n", "b·∫°n b√®", "gia ƒë√¨nh", "m√πa xu√¢n",
                "m√πa h·∫°", "m√πa thu", "m√πa ƒë√¥ng", "tr√°i tim", "n·ª• c∆∞·ªùi",
                "√°nh s√°ng", "b√≥ng t·ªëi", "s·ª©c kh·ªèe", "h·∫°nh ph√∫c", "t√¨nh y√™u"
            ],
            2: [
                "th√†nh c√¥ng", "c·ªë g·∫Øng", "ki√™n tr√¨", "ph·∫•n ƒë·∫•u", "∆∞·ªõc m∆°",
                "ho√†i b√£o", "tri th·ª©c", "vƒÉn h√≥a", "l·ªãch s·ª≠", "truy·ªÅn th·ªëng",
                "ph√°t tri·ªÉn", "c√¥ng ngh·ªá", "khoa h·ªçc", "ngh·ªá thu·∫≠t", "s√°ng t·∫°o"
            ],
            3: [
                "ƒë·ªôc l·∫≠p t·ª± do", "c√°ch m·∫°ng c√¥ng nghi·ªáp", "ph√°t tri·ªÉn b·ªÅn v·ªØng",
                "kinh t·∫ø th·ªã tr∆∞·ªùng", "to√†n c·∫ßu h√≥a", "chuy·ªÉn ƒë·ªïi s·ªë",
                "tr√≠ tu·ªá nh√¢n t·∫°o", "b·∫£o v·ªá m√¥i tr∆∞·ªùng", "bi·∫øn ƒë·ªïi kh√≠ h·∫≠u",
                "vƒÉn minh nh√¢n lo·∫°i", "di s·∫£n vƒÉn h√≥a", "danh lam th·∫Øng c·∫£nh"
            ]
        }
        
        word_list = difficulty_words.get(self.difficulty_level, difficulty_words[1])
        
        # Claude prompt v·ªõi ƒë·ªô ch√≠nh x√°c cao
        prompt = f"""Create a Vietnamese word scramble puzzle with HIGH ACCURACY.

STRICT REQUIREMENTS:
1. Difficulty level: {self.difficulty_level}/3
2. Word/phrase length: {'4-6' if self.difficulty_level == 1 else '6-8' if self.difficulty_level == 2 else '8-12'} letters
3. MUST scramble LETTERS (not words)
4. KEEP consonant clusters together: th, tr, ch, ph, nh, ng, gh, kh, gi, qu
5. Keep tone marks with their letters
6. The original word MUST be a common, valid Vietnamese word/phrase

Return ONLY valid JSON:
{{
  "original": "exact Vietnamese word/phrase",
  "scrambled": "scrambled letters separated by /"
}}

Example for reference:
{{
  "original": "th√†nh c√¥ng",
  "scrambled": "th / √¥ / c / g / n / √† / n / h"
}}

IMPORTANT: Ensure the word is appropriate and commonly used in Vietnamese."""

        messages = [
            {
                "role": "system", 
                "content": "You are a Vietnamese language expert. Create accurate word puzzles with correct spelling and tones. Prioritize accuracy over creativity."
            },
            {"role": "user", "content": prompt}
        ]
        
        try:
            response = await call_api(messages, model=CLAUDE_MODEL, max_tokens=150, temperature=0.3)
            
            if response:
                json_start = response.find('{')
                json_end = response.rfind('}') + 1
                if json_start != -1 and json_end > json_start:
                    json_str = response[json_start:json_end]
                    data = json.loads(json_str)
                    
                    original = data.get("original", "").strip()
                    scrambled = data.get("scrambled", "").strip()
                    
                    if original and scrambled:
                        return original, scrambled
        except Exception as e:
            logger.error(f"Generate word puzzle error: {e}")
        
        # Fallback v·ªõi x√°o tr·ªôn th√¥ng minh
        word = random.choice(word_list)
        
        def smart_scramble(text):
            clusters = ['th', 'tr', 'ch', 'ph', 'nh', 'ng', 'gh', 'kh', 'gi', 'qu']
            result = []
            i = 0
            text_no_space = text.replace(' ', '')
            
            while i < len(text_no_space):
                found_cluster = False
                for cluster in clusters:
                    if text_no_space[i:i+len(cluster)].lower() == cluster:
                        result.append(text_no_space[i:i+len(cluster)])
                        i += len(cluster)
                        found_cluster = True
                        break
                
                if not found_cluster:
                    result.append(text_no_space[i])
                    i += 1
            
            random.shuffle(result)
            return ' / '.join(result)
        
        scrambled = smart_scramble(word)
        return word, scrambled
        
    def check_answer(self, answer: str) -> Tuple[bool, str]:
        answer = answer.lower().strip()
        self.attempts += 1
        
        answer_normalized = ''.join(answer.split())
        original_normalized = ''.join(self.current_word.lower().split())
        
        if answer_normalized == original_normalized:
            base_points = (self.max_attempts - self.attempts + 1) * 100
            difficulty_bonus = self.difficulty_level * 50
            points = base_points + difficulty_bonus
            
            self.score += points
            time_taken = (datetime.now() - self.start_time).seconds
            
            return True, f"""‚úÖ **CH√çNH X√ÅC!**

ƒê√°p √°n: **{self.current_word}**
ƒêi·ªÉm: +{points} (C∆° b·∫£n: {base_points} + ƒê·ªô kh√≥: {difficulty_bonus})
T·ªïng ƒëi·ªÉm: {self.score}
Th·ªùi gian: {time_taken}s

G√µ 'ti·∫øp' ƒë·ªÉ ch∆°i ti·∫øp ho·∫∑c 'd·ª´ng' ƒë·ªÉ k·∫øt th√∫c"""
            
        if self.attempts >= self.max_attempts:
            return False, f"""‚ùå H·∫øt l∆∞·ª£t!

ƒê√°p √°n l√†: **{self.current_word}**

G√µ 'ti·∫øp' ƒë·ªÉ ch∆°i c√¢u m·ªõi ho·∫∑c 'd·ª´ng' ƒë·ªÉ k·∫øt th√∫c"""
            
        remaining = self.max_attempts - self.attempts
        return False, f"‚ùå Sai r·ªìi! C√≤n {remaining} l·∫ßn th·ª≠\n\nüî§ {self.scrambled}"

async def call_api(messages: List[dict], model: str = None, max_tokens: int = 400, temperature: float = None) -> str:
    try:
        headers = {
            "Authorization": f"Bearer {VERCEL_API_KEY}",
            "Content-Type": "application/json"
        }
        
        # Temperature th·∫•p cho Claude ƒë·ªÉ tƒÉng ƒë·ªô ch√≠nh x√°c
        if temperature is None:
            temperature = 0.3 if model == CLAUDE_MODEL else 0.7
        
        data = {
            "model": model or CHAT_MODEL,
            "messages": messages,
            "max_tokens": max_tokens,
            "temperature": temperature,
            "top_p": 0.9
        }
        
        response = requests.post(
            f"{BASE_URL}/chat/completions",
            headers=headers,
            json=data,
            timeout=25
        )
        
        if response.status_code == 200:
            result = response.json()
            return result['choices'][0]['message']['content']
        else:
            logger.error(f"API error: {response.status_code}")
            return None
            
    except Exception as e:
        logger.error(f"API error: {e}")
        return None

async def generate_quiz(chat_id: int) -> dict:
    global quiz_history
    
    if chat_id not in quiz_history:
        quiz_history[chat_id] = []
    
    recent_questions = quiz_history[chat_id][-10:] if len(quiz_history[chat_id]) > 0 else []
    history_text = "\n".join(recent_questions) if recent_questions else "None"
    
    topics = ["L·ªãch s·ª≠ Vi·ªát Nam", "ƒê·ªãa l√Ω Vi·ªát Nam", "VƒÉn h√≥a Vi·ªát Nam", "·∫®m th·ª±c Vi·ªát Nam", "Khoa h·ªçc Vi·ªát Nam", "Th·ªÉ thao Vi·ªát Nam", "Kinh t·∫ø Vi·ªát Nam", "Gi√°o d·ª•c Vi·ªát Nam"]
    topic = random.choice(topics)
    
    # Claude prompt v·ªõi y√™u c·∫ßu ƒë·ªô ch√≠nh x√°c cao
    prompt = f"""Create a quiz question about {topic} with MAXIMUM ACCURACY.

CRITICAL REQUIREMENTS:
1. MUST be 100% factually accurate and verifiable
2. Use reliable, well-documented facts only
3. Different from previously asked questions
4. 4 options with ONLY 1 correct answer
5. All wrong options must be clearly incorrect but plausible
6. Provide educational explanation with source if possible

Previously asked questions:
{history_text}

Return ONLY valid JSON in Vietnamese:
{{
  "topic": "{topic}",
  "question": "clear, accurate question in Vietnamese",
  "options": ["A. option 1", "B. option 2", "C. option 3", "D. option 4"],
  "answer": "A or B or C or D",
  "explain": "accurate explanation in Vietnamese with facts"
}}

CRITICAL: Double-check all facts before creating the question. Prioritize accuracy over difficulty."""

    messages = [
        {
            "role": "system", 
            "content": "You are a Vietnamese education expert with deep knowledge of verified facts about Vietnam. Create only 100% accurate quiz questions. If unsure about any fact, use a different question. Accuracy is paramount."
        },
        {"role": "user", "content": prompt}
    ]
    
    try:
        response = await call_api(messages, model=CLAUDE_MODEL, max_tokens=500, temperature=0.2)
        
        if not response:
            return None
        
        json_start = response.find('{')
        json_end = response.rfind('}') + 1
        
        if json_start == -1 or json_end <= json_start:
            logger.error(f"No JSON found in response: {response}")
            return None
            
        json_str = response[json_start:json_end]
        
        try:
            data = json.loads(json_str)
        except json.JSONDecodeError as e:
            logger.error(f"JSON parse error: {e}, Response: {json_str}")
            return None
        
        quiz = {
            "topic": data.get("topic", topic),
            "question": data.get("question", ""),
            "options": data.get("options", []),
            "correct": data.get("answer", ""),
            "explanation": data.get("explain", "")
        }
        
        if quiz["correct"] and len(quiz["correct"]) > 0:
            quiz["correct"] = quiz["correct"][0].upper()
        
        if (quiz["question"] and 
            len(quiz["options"]) == 4 and 
            quiz["correct"] in ["A", "B", "C", "D"]):
            
            quiz_history[chat_id].append(quiz["question"][:100])
            return quiz
        else:
            logger.error(f"Invalid quiz data: {quiz}")
            return None
            
    except Exception as e:
        logger.error(f"Generate quiz error: {e}")
        return None

async def goodnight_scheduler(app):
    while True:
        now = datetime.now()
        target_time = now.replace(hour=23, minute=0, second=0, microsecond=0)
        
        if now >= target_time:
            target_time += timedelta(days=1)
        
        wait_seconds = (target_time - now).total_seconds()
        logger.info(f"Waiting {wait_seconds} seconds until 23:00")
        
        await asyncio.sleep(wait_seconds)
        
        await send_goodnight_message(app)
        
        await asyncio.sleep(60)

async def send_goodnight_message(app):
    chats = get_all_chats()
    
    messages = [
        "Linh ch√∫c c√°c t√¨nh y√™u ng·ªß ngon ‚ù§Ô∏è‚ù§Ô∏è",
        "23h r·ªìi! Ng·ªß ngon nh√© m·ªçi ng∆∞·ªùi üò¥üíï",
        "Ch√∫c c·∫£ nh√† c√≥ gi·∫•c ng·ªß th·∫≠t ngon üåô‚ú®",
        "Good night! Ng·ªß ngon v√† m∆° ƒë·∫πp nh√© üí´‚ù§Ô∏è",
        "Linh ch√∫c m·ªçi ng∆∞·ªùi ng·ªß ngon! Mai g·∫∑p l·∫°i nha üòò"
    ]
    
    message = random.choice(messages)
    
    for chat_id, chat_type in chats:
        try:
            await app.bot.send_message(chat_id=chat_id, text=message)
            logger.info(f"Sent goodnight to {chat_id}")
        except Exception as e:
            logger.error(f"Failed to send to {chat_id}: {e}")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat = update.effective_chat
    save_chat_info(chat.id, chat.type, chat.title)
    
    await update.message.reply_text("""
üëã **Xin ch√†o! M√¨nh l√† Linh!**

üéÆ **Game (Claude AI - ƒê·ªô ch√≠nh x√°c cao):**
/guessnumber - ƒêo√°n s·ªë
/vuatiengviet - S·∫Øp x·∫øp ch·ªØ c√°i (3 c·∫•p ƒë·ªô)
/quiz - C√¢u ƒë·ªë v·ªÅ Vi·ªát Nam
/stopquiz - D·ª´ng c√¢u ƒë·ªë

üèÜ /leaderboard - BXH 24h
üìä /stats - ƒêi·ªÉm c·ªßa b·∫°n

üí¨ Chat v·ªõi Linh (GPT)
üíï M·ªói 23h Linh s·∫Ω ch√∫c ng·ªß ngon!
""")

async def start_guess_number(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    
    if chat_id in active_games:
        del active_games[chat_id]
        
    game = GuessNumberGame(chat_id)
    active_games[chat_id] = {"type": "guessnumber", "game": game}
    
    await update.message.reply_text(f"""üéÆ **ƒêO√ÅN S·ªê 1-100**

üí° {game.riddle}
üìù 10 l·∫ßn | üí∞ 1000ƒë
/hint - G·ª£i √Ω (-100ƒë)

ƒêo√°n ƒëi!""")

async def hint_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    
    if chat_id not in active_games or active_games[chat_id]["type"] != "guessnumber":
        await update.message.reply_text("‚ùå Kh√¥ng trong game ƒëo√°n s·ªë!")
        return
        
    game = active_games[chat_id]["game"]
    await update.message.reply_text(game.get_hint())

async def start_vua_tieng_viet(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    
    if chat_id in active_games:
        del active_games[chat_id]
    
    game = VuaTiengVietGame(chat_id)
    active_games[chat_id] = {"type": "vuatiengviet", "game": game}
    
    loading_msg = await update.message.reply_text("‚è≥ Claude AI ƒëang t·∫°o c√¢u ƒë·ªë (ƒë·ªô ch√≠nh x√°c cao)...")
    
    message = await game.start_new_round()
    await loading_msg.edit_text(message)

async def quiz_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    quiz_mode[chat_id] = True
    quiz_count[chat_id] = 1
    
    loading_msg = await update.message.reply_text("‚è≥ Claude AI ƒëang t·∫°o c√¢u h·ªèi (ƒë·ªô ch√≠nh x√°c cao)...")
    
    quiz = await generate_quiz(chat_id)
    
    if not quiz:
        await loading_msg.edit_text("‚ùå L·ªói t·∫°o c√¢u h·ªèi! Th·ª≠ l·∫°i /quiz")
        if chat_id in quiz_mode:
            del quiz_mode[chat_id]
        return
    
    quiz_sessions[chat_id] = quiz
    
    keyboard = []
    for option in quiz["options"]:
        keyboard.append([InlineKeyboardButton(option, callback_data=f"quiz_{option[0]}")])
    keyboard.append([InlineKeyboardButton("‚ùå D·ª´ng", callback_data="quiz_stop")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    topic_emojis = {
        "L·ªãch s·ª≠ Vi·ªát Nam": "üìú",
        "ƒê·ªãa l√Ω Vi·ªát Nam": "üó∫Ô∏è",
        "·∫®m th·ª±c Vi·ªát Nam": "üçú",
        "VƒÉn h√≥a Vi·ªát Nam": "üé≠",
        "Khoa h·ªçc Vi·ªát Nam": "üî¨",
        "Th·ªÉ thao Vi·ªát Nam": "‚öΩ",
        "Kinh t·∫ø Vi·ªát Nam": "üí∞",
        "Gi√°o d·ª•c Vi·ªát Nam": "üìö"
    }
    
    emoji = topic_emojis.get(quiz.get("topic", ""), "‚ùì")
    message = f"{emoji} **C√ÇU {quiz_count[chat_id]} - {quiz.get('topic', '').upper()}**\n\n{quiz['question']}"
    
    await loading_msg.edit_text(message, reply_markup=reply_markup)

async def stop_quiz(update: Update, context: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id
    
    total_questions = quiz_count.get(chat_id, 0) - 1
    
    if chat_id in quiz_mode:
        del quiz_mode[chat_id]
    if chat_id in quiz_sessions:
        del quiz_sessions[chat_id]
    if chat_id in quiz_count:
        del quiz_count[chat_id]
    if chat_id in quiz_history:
        quiz_history[chat_id] = []
        
    await update.message.reply_text(f"‚úÖ ƒê√£ d·ª´ng c√¢u ƒë·ªë!\nüìä B·∫°n ƒë√£ tr·∫£ l·ªùi {total_questions} c√¢u")

async def leaderboard_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    scores = get_leaderboard_24h()
    
    message = "üèÜ **BXH 24H**\n\n"
    
    if scores:
        for i, (username, total_score, games_played) in enumerate(scores, 1):
            medal = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else f"{i}."
            message += f"{medal} {username}: {total_score:,}ƒë\n"
    else:
        message += "Ch∆∞a c√≥ ai ch∆°i!"
        
    await update.message.reply_text(message)

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    stats = get_user_stats_24h(user.id)
    
    message = f"üìä **{user.first_name} (24H)**\n\n"
    message += f"üí∞ T·ªïng: {stats['total']:,}ƒë\n"
    
    if stats['games']:
        message += "\n"
        for game_type, data in stats['games'].items():
            game_name = {
                "guessnumber": "ƒêo√°n s·ªë",
                "vuatiengviet": "Vua Ti·∫øng Vi·ªát",
                "quiz": "C√¢u ƒë·ªë"
            }.get(game_type, game_type)
            message += f"{game_name}: {data['total']:,}ƒë ({data['played']} l·∫ßn)\n"
            
    await update.message.reply_text(message)

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    
    data = query.data
    chat_id = update.effective_chat.id
    user = update.effective_user
    username = user.username or user.first_name
    
    if data.startswith("quiz_"):
        if data == "quiz_stop":
            total_questions = quiz_count.get(chat_id, 1) - 1
            
            if chat_id in quiz_mode:
                del quiz_mode[chat_id]
            if chat_id in quiz_sessions:
                del quiz_sessions[chat_id]
            if chat_id in quiz_count:
                del quiz_count[chat_id]
            if chat_id in quiz_history:
                quiz_history[chat_id] = []
                
            await query.message.edit_text(f"‚úÖ ƒê√£ d·ª´ng c√¢u ƒë·ªë!\nüìä B·∫°n ƒë√£ tr·∫£ l·ªùi {total_questions} c√¢u")
            return
            
        if chat_id not in quiz_sessions:
            await query.message.edit_text("‚ùå H·∫øt gi·ªù!")
            return
            
        quiz = quiz_sessions[chat_id]
        answer = data.split("_")[1]
        
        if answer == quiz["correct"]:
            save_score(user.id, username, "quiz", 200)
            result = f"‚úÖ Ch√≠nh x√°c! (+200ƒë)\n\n{quiz['explanation']}"
        else:
            result = f"‚ùå Sai r·ªìi! ƒê√°p √°n: {quiz['correct']}\n\n{quiz['explanation']}"
        
        del quiz_sessions[chat_id]
        
        await query.message.edit_text(result)
        
        if chat_id in quiz_mode:
            wait_msg = await context.bot.send_message(
                chat_id, 
                "‚è≥ **ƒê·ª£i 5 gi√¢y cho c√¢u ti·∫øp theo...**"
            )
            
            await asyncio.sleep(5)
            await wait_msg.delete()
            
            quiz_count[chat_id] = quiz_count.get(chat_id, 1) + 1
            
            loading_msg = await context.bot.send_message(chat_id, "‚è≥ Claude AI ƒëang t·∫°o c√¢u h·ªèi m·ªõi...")
            
            quiz = await generate_quiz(chat_id)
            
            if not quiz:
                await loading_msg.edit_text("‚ùå L·ªói t·∫°o c√¢u h·ªèi! D√πng /quiz ƒë·ªÉ th·ª≠ l·∫°i")
                if chat_id in quiz_mode:
                    del quiz_mode[chat_id]
                return
            
            quiz_sessions[chat_id] = quiz
            
            keyboard = []
            for option in quiz["options"]:
                keyboard.append([InlineKeyboardButton(option, callback_data=f"quiz_{option[0]}")])
            keyboard.append([InlineKeyboardButton("‚ùå D·ª´ng", callback_data="quiz_stop")])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            topic_emojis = {
                "L·ªãch s·ª≠ Vi·ªát Nam": "üìú",
                "ƒê·ªãa l√Ω Vi·ªát Nam": "üó∫Ô∏è",
                "·∫®m th·ª±c Vi·ªát Nam": "üçú",
                "VƒÉn h√≥a Vi·ªát Nam": "üé≠",
                "Khoa h·ªçc Vi·ªát Nam": "üî¨",
                "Th·ªÉ thao Vi·ªát Nam": "‚öΩ",
                "Kinh t·∫ø Vi·ªát Nam": "üí∞",
                "Gi√°o d·ª•c Vi·ªát Nam": "üìö"
            }
            
            emoji = topic_emojis.get(quiz.get("topic", ""), "‚ùì")
            message = f"{emoji} **C√ÇU {quiz_count[chat_id]} - {quiz.get('topic', '').upper()}**\n\n{quiz['question']}"
            
            await loading_msg.edit_text(message, reply_markup=reply_markup)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    message = update.message.text
    chat_id = update.effective_chat.id
    user = update.effective_user
    username = user.username or user.first_name
    
    chat = update.effective_chat
    save_chat_info(chat.id, chat.type, chat.title)
    
    if chat_id in active_games:
        game_info = active_games[chat_id]
        
        if game_info["type"] == "guessnumber":
            try:
                guess = int(message)
                if 1 <= guess <= 100:
                    is_finished, response = game_info["game"].make_guess(guess)
                    await update.message.reply_text(response)
                    
                    if is_finished and "ƒê√∫ng" in response:
                        save_score(user.id, username, "guessnumber", game_info["game"].score)
                    
                    if is_finished:
                        del active_games[chat_id]
                else:
                    await update.message.reply_text("‚ùå T·ª´ 1-100 th√¥i!")
            except ValueError:
                await update.message.reply_text("‚ùå Nh·∫≠p s·ªë!")
                
        elif game_info["type"] == "vuatiengviet":
            game = game_info["game"]
            
            if message.lower() in ["ti·∫øp", "tiep"]:
                loading_msg = await update.message.reply_text("‚è≥ Claude AI ƒëang t·∫°o c√¢u m·ªõi...")
                msg = await game.start_new_round()
                await loading_msg.edit_text(msg)
            elif message.lower() in ["d·ª´ng", "dung", "stop"]:
                if game.score > 0:
                    save_score(user.id, username, "vuatiengviet", game.score)
                await update.message.reply_text(f"üìä K·∫øt th√∫c!\nT·ªïng ƒëi·ªÉm: {game.score}")
                del active_games[chat_id]
            else:
                is_correct, response = game.check_answer(message)
                await update.message.reply_text(response)
                
                if is_correct and "d·ª´ng" not in response.lower():
                    loading_msg = await context.bot.send_message(chat_id, "‚è≥ Claude AI ƒëang t·∫°o c√¢u m·ªõi...")
                    await asyncio.sleep(2)
                    msg = await game.start_new_round()
                    await loading_msg.edit_text(msg)
        return
    
    # Chat v·ªõi GPT
    if chat_id not in chat_history:
        chat_history[chat_id] = []
        
    chat_history[chat_id].append({"role": "user", "content": message})
    
    if len(chat_history[chat_id]) > 4:
        chat_history[chat_id] = chat_history[chat_id][-4:]
    
    messages = [
        {"role": "system", "content": "B·∫°n l√† Linh - c√¥ g√°i Vi·ªát Nam vui v·∫ª, th√¢n thi·ªán. Tr·∫£ l·ªùi ng·∫Øn g·ªçn."}
    ]
    messages.extend(chat_history[chat_id])
    
    response = await call_api(messages, max_tokens=300)
    
    if response:
        chat_history[chat_id].append({"role": "assistant", "content": response})
        await update.message.reply_text(response)
    else:
        await update.message.reply_text("üòÖ Xin l·ªói, m√¨nh ƒëang g·∫∑p l·ªói!")

async def post_init(application: Application) -> None:
    global goodnight_task
    goodnight_task = asyncio.create_task(goodnight_scheduler(application))
    logger.info("Goodnight scheduler started!")

async def post_shutdown(application: Application) -> None:
    global goodnight_task
    if goodnight_task:
        goodnight_task.cancel()
        try:
            await goodnight_task
        except asyncio.CancelledError:
            pass

def main():
    application = Application.builder().token(BOT_TOKEN).build()
    
    application.post_init = post_init
    application.post_shutdown = post_shutdown
    
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("guessnumber", start_guess_number))
    application.add_handler(CommandHandler("vuatiengviet", start_vua_tieng_viet))
    application.add_handler(CommandHandler("quiz", quiz_command))
    application.add_handler(CommandHandler("stopquiz", stop_quiz))
    application.add_handler(CommandHandler("hint", hint_command))
    application.add_handler(CommandHandler("leaderboard", leaderboard_command))
    application.add_handler(CommandHandler("stats", stats_command))
    
    application.add_handler(CallbackQueryHandler(button_callback))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    logger.info("Linh Bot started! üíï")
    application.run_polling()

if __name__ == "__main__":
    main()
